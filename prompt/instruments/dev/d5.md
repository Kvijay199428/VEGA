Next, we create the End-to-End Integration Architecture, combining Instrument Loader, Market Session Engine, Multi-Broker Abstraction Layer (MBAL), Dynamic Product Eligibility Cache, and Risk Enforcement. This will give a complete picture of how orders, positions, and market data flow through the system.

MODULE 5 — END-TO-END INTEGRATION ARCHITECTURE
1. Overview

The integrated architecture ensures:

Orders are validated, routed, and executed across multiple brokers.

Instrument data is fully normalized and kept up-to-date.

Client-level and symbol-level risk is enforced in real-time.

Dynamic eligibility (MTF, MIS, CNC) is checked before order placement.

Market sessions, auction periods, and call markets are handled automatically.

Portfolio aggregation and P&L are normalized across brokers.

2. Architecture Components
2.1 Instrument Loader & Cache

Responsibilities:

Load JSON instruments (BOD, MIS, MTF, Suspended) daily.

Normalize and store in SQLite (vega_trade.db) with indexes on instrument_key, trading_symbol, segment.

Support gzip parsing and incremental updates.

Keep a dynamic cache for fast eligibility lookup.

Tables:

CREATE TABLE instruments (
    instrument_key TEXT PRIMARY KEY,
    segment TEXT NOT NULL,
    name TEXT NOT NULL,
    exchange TEXT NOT NULL,
    instrument_type TEXT NOT NULL,
    trading_symbol TEXT NOT NULL,
    lot_size INTEGER,
    tick_size REAL,
    freeze_quantity REAL,
    security_type TEXT,
    mtf_enabled BOOLEAN DEFAULT FALSE,
    mtf_bracket REAL,
    intraday_margin REAL,
    intraday_leverage REAL,
    qty_multiplier REAL,
    UNIQUE(trading_symbol, segment)
);

2.2 Dynamic Product Eligibility Cache

Cached eligibility checks for MTF, MIS, CNC.

Keyed by instrument_key and client_id.

Auto-refresh at 6 AM and on significant updates.

public class ProductEligibilityCache {
    private final Map<String, Eligibility> cache = new ConcurrentHashMap<>();

    public Eligibility get(String clientId, String instrumentKey) {
        return cache.get(clientId + "|" + instrumentKey);
    }

    public void refresh(List<Instrument> instruments) {
        instruments.forEach(instr -> cache.put(instr.getInstrumentKey(),
                new Eligibility(instr.isMtfEnabled(), instr.getIntradayMargin(), instr.getIntradayLeverage())));
    }
}

2.3 Market Session Engine

Validates auction/call market windows, trade-for-trade periods, FO rollover.

Provides isTradingAllowed(instrumentKey, sessionTime) API.

public class MarketSessionEngine {
    public boolean isTradingAllowed(String instrumentKey, LocalDateTime timestamp) {
        // check auction, call market, and freeze periods
        return !auctionPeriods.contains(timestamp);
    }
}

2.4 Multi-Broker Abstraction Layer (MBAL)

Unified adapter for all brokers (Upstox, Fyers, Zerodha, etc.)

Handles:

Order placement / cancellation

Market data subscription

Position aggregation

Risk enforcement hooks

2.5 Risk Enforcement Engine

Client-level risk limits:

Max daily loss, max order value, max order quantity.

Intraday VaR throttling:

Compute portfolio VaR and prevent new intraday orders if threshold exceeded.

Symbol-level quantity caps:

Restrict orders exceeding allowed quantity per symbol.

Portfolio Margin (SPAN-style):

FO options/futures positions are aggregated for margin calculations.

Dynamic price band ingestion:

Maintain min/max price per instrument and enforce checks at order entry.

2.6 Order Flow Sequence

Frontend / CLI / REST → sends order request with symbol, qty, product_type.

Symbol Resolver → maps symbol → instrument_key.

Market Session Engine → validates session and trading window.

Product Eligibility Cache → checks MTF/MIS/CNC eligibility.

Risk Engine → enforces:

Client-level limits

Intraday VaR

Quantity caps

Price bands

MBAL → routes order to appropriate broker adapter.

Broker Adapter → sends order via broker API (REST / WebSocket / FIX).

Execution / Event Streaming → updates positions and P&L in MBAL.

Portfolio Aggregator → merges positions from all brokers for dashboard / reporting.

2.7 Event & Market Data Flow

WebSocket subscriptions handled by MBAL.

Normalized events pushed to:

Realtime portfolio engine

RMS engine

Frontend React autocomplete / dashboards

flowchart LR
    Frontend[Frontend Vite+React / CLI / REST] --> Resolver[Symbol Resolver]
    Resolver --> Session[Market Session Engine]
    Session --> Eligibility[Product Eligibility Cache]
    Eligibility --> Risk[Risk Enforcement Engine]
    Risk --> MBAL[Multi-Broker Abstraction Layer]
    MBAL --> BrokerAdapter[Broker Adapter (Upstox/Fyers/...)]
    BrokerAdapter --> Execution[Execution / Event Stream]
    Execution --> Portfolio[Portfolio Aggregator]
    Portfolio --> Frontend

2.8 Frontend / CLI Integration

React Autocomplete: GET /api/instruments/search?query=RELIANCE

REST Endpoints:

/api/order/place

/api/order/status

/api/portfolio

CLI Commands:

./trader-cli place-order --broker UPSTOX --symbol RELIANCE --qty 100 --product CNC
./trader-cli portfolio
./trader-cli search RELIANCE

2.9 Unit / Integration Tests

Use SQLite in-memory mode for DAO testing.

Mock MBAL adapters for broker interaction.

Test Instrument Loader + Cache refresh.

Test Risk Engine validations: client-level, symbol-level, intraday VaR.

Test Session Engine: auction/call market enforcement.

Test Full order flow via CLI/REST.

2.10 Notes / Next Steps

Daily automated ingestion:

BOD instruments

PCA / Surveillance lists

IPO day-0 restrictions

Dynamic price bands

FO rollover scripts to automatically move expired contracts.

Continuous integration with MBAL ensures multi-broker redundancy.

Risk policies enforced before hitting any broker API.

At this point, the system design covers:

Instrument Services / Loader

Product Eligibility Cache (MTF/MIS/CNC)

Market Session Engine

Risk Engine (client-level, intraday VaR, SPAN-style)

Multi-Broker Abstraction Layer

Frontend / CLI / REST integration

End-to-end flow from order entry → execution → portfolio aggregation