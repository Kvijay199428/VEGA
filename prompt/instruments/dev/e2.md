Let’s outline a full Java backend project skeleton for your trading system with SQLite, instrument services, settings, logging, CLI, REST, and multi-broker abstraction. I’ll provide the directory structure, Maven setup, key modules, and sample code to get you running end-to-end.

VEGA-TRADER JAVA BACKEND SKELETON
vega-trader/
├─ backend/
│  ├─ java/
│  │  ├─ vega-trader/
│  │  │  ├─ config/
│  │  │  │   ├─ DatabaseConfig.java         # SQLite JdbcTemplate config
│  │  │  │   └─ WebSocketConfig.java        # Upstox WS subscription resolver
│  │  │  │
│  │  │  ├─ dao/
│  │  │  │   ├─ InstrumentDao.java
│  │  │  │   ├─ SettingsDao.java
│  │  │  │   └─ AuditLogDao.java
│  │  │  │
│  │  │  ├─ model/
│  │  │  │   ├─ Instrument.java
│  │  │  │   ├─ Settings.java
│  │  │  │   └─ AuditLog.java
│  │  │  │
│  │  │  ├─ service/
│  │  │  │   ├─ InstrumentService.java     # Load/update instruments
│  │  │  │   ├─ SettingsService.java       # Runtime dynamic config
│  │  │  │   ├─ RiskEngineService.java     # MIS / MTF / VaR / Symbol caps
│  │  │  │   └─ LoggerService.java         # Audit logging
│  │  │  │
│  │  │  ├─ cli/
│  │  │  │   └─ TraderCLI.java             # CLI loader, settings updater
│  │  │  │
│  │  │  ├─ rest/
│  │  │  │   ├─ SettingsController.java    # REST API for settings
│  │  │  │   └─ InstrumentController.java  # Search / autocomplete / info
│  │  │  │
│  │  │  ├─ util/
│  │  │  │   ├─ GzipJsonLoader.java        # gzip JSON loader + indexing
│  │  │  │   └─ RegexValidator.java        # instrumentKey, symbol patterns
│  │  │  │
│  │  │  └─ Main.java                       # Entry point
│  │  │
│  │  └─ database/
│  │      └─ vega_trade.db                  # SQLite DB
│  │
│  └─ resources/
│      ├─ flyway/
│      │   ├─ V1__create_settings_table.sql
│      │   ├─ V2__create_instrument_table.sql
│      │   └─ V3__create_audit_log_table.sql
│      └─ config.properties                 # DB file path, Upstox API keys
└─ frontend/
   ├─ vite-react/
   │   ├─ src/
   │   │   ├─ components/
   │   │   │   ├─ SettingsPanel.jsx
   │   │   │   ├─ InstrumentSearch.jsx
   │   │   │   └─ AuditLogViewer.jsx
   │   │   ├─ api/
   │   │   │   ├─ instrumentApi.js
   │   │   │   └─ settingsApi.js
   │   │   └─ App.jsx
   │   └─ package.json
   └─ curl-scripts/
       ├─ get-settings.sh
       ├─ update-settings.sh
       └─ instrument-search.sh

1. Flyway SQL Scripts
V1__create_settings_table.sql
CREATE TABLE settings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    category TEXT NOT NULL,
    key TEXT NOT NULL,
    value TEXT NOT NULL,
    description TEXT,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(category,key)
);

V2__create_instrument_table.sql
CREATE TABLE instrument (
    instrument_key TEXT PRIMARY KEY,
    segment TEXT,
    name TEXT,
    exchange TEXT,
    instrument_type TEXT,
    trading_symbol TEXT,
    lot_size INTEGER,
    freeze_quantity INTEGER,
    exchange_token TEXT,
    tick_size REAL,
    short_name TEXT,
    mtf_enabled BOOLEAN,
    mis_enabled BOOLEAN,
    intraday_margin REAL,
    intraday_leverage REAL,
    security_type TEXT,
    expiry BIGINT,
    underlying_key TEXT,
    strike_price REAL
);

V3__create_audit_log_table.sql
CREATE TABLE audit_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    level TEXT NOT NULL,
    category TEXT NOT NULL,
    message TEXT NOT NULL,
    metadata TEXT
);

2. Instrument Loader CLI Skeleton
public class TraderCLI {
    public static void main(String[] args) {
        // Load Instruments
        if(args.length > 0 && args[0].equals("load-instruments")) {
            InstrumentService loader = new InstrumentService(DatabaseConfig.getJdbcTemplate());
            loader.loadFromGzip("https://assets.upstox.com/market-quote/instruments/exchange/complete.json.gz");
            System.out.println("Instruments loaded successfully!");
        }

        // Settings CLI
        if(args.length > 0 && args[0].equals("settings")) {
            SettingsService settings = new SettingsService(DatabaseConfig.getJdbcTemplate());
            if(args[1].equals("get")) {
                System.out.println(settings.getValue(args[2], args[3]));
            } else if(args[1].equals("update")) {
                settings.updateValue(args[2], args[3], args[4]);
                System.out.println("Settings updated.");
            }
        }
    }
}

3. Upstox WebSocket Subscription Resolver

Service layer in InstrumentService subscribes to instrument streams.

Supports auto-subscription for FO, MIS, MTF instruments.

Uses instrument_key for identification.

Updates cache in SQLite and runtime SettingsService if eligibility changes.

4. Java DAO Layer (JdbcTemplate Example)
@Repository
public class InstrumentDao {
    private final JdbcTemplate jdbc;

    public InstrumentDao(JdbcTemplate jdbc) { this.jdbc = jdbc; }

    public void save(Instrument i) {
        jdbc.update("INSERT OR REPLACE INTO instrument VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)",
            i.getInstrumentKey(),
            i.getSegment(),
            i.getName(),
            i.getExchange(),
            i.getInstrumentType(),
            i.getTradingSymbol(),
            i.getLotSize(),
            i.getFreezeQuantity(),
            i.getExchangeToken(),
            i.getTickSize(),
            i.getShortName(),
            i.isMtfEnabled(),
            i.isMisEnabled(),
            i.getIntradayMargin(),
            i.getIntradayLeverage(),
            i.getSecurityType(),
            i.getExpiry()
        );
    }

    public List<Instrument> searchBySymbol(String symbol) {
        return jdbc.query("SELECT * FROM instrument WHERE trading_symbol LIKE ? LIMIT 20", 
            new Object[]{symbol + "%"},
            (rs, rowNum) -> new Instrument(
                rs.getString("instrument_key"),
                rs.getString("segment"),
                rs.getString("name"),
                rs.getString("exchange"),
                rs.getString("instrument_type"),
                rs.getString("trading_symbol"),
                rs.getInt("lot_size"),
                rs.getInt("freeze_quantity"),
                rs.getString("exchange_token"),
                rs.getDouble("tick_size"),
                rs.getString("short_name"),
                rs.getBoolean("mtf_enabled"),
                rs.getBoolean("mis_enabled"),
                rs.getDouble("intraday_margin"),
                rs.getDouble("intraday_leverage"),
                rs.getString("security_type"),
                rs.getLong("expiry")
            )
        );
    }
}

5. REST / Vite-React Integration
REST endpoints (Spring Boot style)
@GetMapping("/api/instruments/search")
public List<Instrument> search(@RequestParam String symbol) {
    return instrumentService.searchBySymbol(symbol);
}

@GetMapping("/api/settings")
public Map<String,String> getSettings(@RequestParam String category) {
    return settingsService.getAllByCategory(category);
}

@PutMapping("/api/settings/{category}/{key}")
public void updateSetting(@PathVariable String category,
                          @PathVariable String key,
                          @RequestBody Map<String,String> body) {
    settingsService.updateValue(category, key, body.get("value"));
}

Frontend Example (React Autocomplete)
const searchInstruments = async (query) => {
  const res = await fetch(`/api/instruments/search?symbol=${query}`);
  return await res.json();
};

// React component: InstrumentSearch.jsx
<Autocomplete
  options={instruments.map(i => i.trading_symbol)}
  onInputChange={(e, value) => searchInstruments(value).then(setInstruments)}
/>

✅ Next Steps

Implement WebSocket subscription resolver to update InstrumentService in real-time.

Load daily PCA / IPO / surveillance / trade-for-trade lists via GzipJsonLoader.

Integrate RiskEngineService:

MIS vs MTF vs CNC enforcement

Intraday margin checks

Symbol-level quantity caps

Unit tests with SQLite in-memory DB.

CLI & REST testing scripts using curl / Vite frontend.