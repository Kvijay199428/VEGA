Next, we implement Multi-Broker Abstraction Layer (MBAL), which standardizes order routing, risk enforcement, and portfolio aggregation across multiple brokers while keeping the core trading engine broker-agnostic.

MODULE 4 — MULTI-BROKER ABSTRACTION LAYER (MBAL)
1. Overview

Provides a unified API for multiple broker connections.

Handles broker-specific features, message formats, and session behavior.

Integrates with RMS, MarketSessionEngine, FO Rollover, and Dynamic Product Eligibility.

Supports order routing, portfolio aggregation, position reconciliation, and event streaming.

Ensures failover if a broker API goes down.

2. Database Layer (Flyway)
V19__broker_registry.sql
CREATE TABLE brokers (
    broker_id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    api_type TEXT NOT NULL, -- REST, WebSocket, FIX, Custom
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    config JSON NOT NULL
);

V20__broker_symbol_mapping.sql
CREATE TABLE broker_symbol_mapping (
    broker_id TEXT NOT NULL,
    instrument_key TEXT NOT NULL,
    broker_symbol TEXT NOT NULL,
    PRIMARY KEY(broker_id, instrument_key)
);

3. Domain Models
Broker.java
public record Broker(
    String brokerId,
    String name,
    String apiType,
    boolean enabled,
    Map<String, String> config
) {}

BrokerSymbolMapping.java
public record BrokerSymbolMapping(
    String brokerId,
    String instrumentKey,
    String brokerSymbol
) {}

4. DAO Layer
BrokerDao.java
public interface BrokerDao {
    Broker find(String brokerId);
    List<Broker> listAll();
    void updateConfig(String brokerId, Map<String,String> config);
}

BrokerSymbolMappingDao.java
public interface BrokerSymbolMappingDao {
    String getBrokerSymbol(String brokerId, String instrumentKey);
    void upsertMapping(String brokerId, String instrumentKey, String brokerSymbol);
}

5. Broker Adapter Interface
BrokerAdapter.java
public interface BrokerAdapter {
    void placeOrder(OrderRequest request);
    void cancelOrder(String brokerOrderId);
    BrokerOrderStatus getOrderStatus(String brokerOrderId);
    List<Position> getPositions();
    void subscribeMarketData(List<String> instrumentKeys);
}

Example: UpstoxAdapter.java
public class UpstoxAdapter implements BrokerAdapter {

    private final UpstoxClient client;

    public UpstoxAdapter(UpstoxClient client) {
        this.client = client;
    }

    @Override
    public void placeOrder(OrderRequest request) {
        String brokerSymbol = request.getBrokerSymbol();
        client.placeOrder(brokerSymbol, request.getQty(), request.getPrice(), request.getOrderType());
    }

    @Override
    public void cancelOrder(String brokerOrderId) {
        client.cancelOrder(brokerOrderId);
    }

    @Override
    public BrokerOrderStatus getOrderStatus(String brokerOrderId) {
        return client.fetchOrderStatus(brokerOrderId);
    }

    @Override
    public List<Position> getPositions() {
        return client.fetchPositions();
    }

    @Override
    public void subscribeMarketData(List<String> instrumentKeys) {
        client.subscribeMarketData(instrumentKeys);
    }
}

6. Multi-Broker Engine
MultiBrokerEngine.java
public class MultiBrokerEngine {

    private final Map<String, BrokerAdapter> adapters;

    public MultiBrokerEngine(Map<String, BrokerAdapter> adapters) {
        this.adapters = adapters;
    }

    public void routeOrder(String brokerId, OrderRequest request) {
        BrokerAdapter adapter = adapters.get(brokerId);
        if(adapter == null) throw new RuntimeException("Broker not found");
        adapter.placeOrder(request);
    }

    public BrokerOrderStatus getOrderStatus(String brokerId, String brokerOrderId) {
        BrokerAdapter adapter = adapters.get(brokerId);
        return adapter.getOrderStatus(brokerOrderId);
    }

    public List<Position> getAggregatedPositions() {
        return adapters.values().stream()
                .flatMap(adapter -> adapter.getPositions().stream())
                .toList();
    }
}

7. Integration with RMS

MBAL calls MarketSessionEngine for session checks.

Calls ClientRiskEvaluator and Intraday VaR before sending orders to brokers.

Receives WebSocket updates from each broker and normalizes into a unified event format.

Supports portfolio aggregation and real-time P&L across brokers.

8. Unit Test Example
@Test
void placeOrderOnUpstox() {
    UpstoxAdapter adapter = mock(UpstoxAdapter.class);
    MultiBrokerEngine engine = new MultiBrokerEngine(Map.of("UPSTOX", adapter));

    OrderRequest order = new OrderRequest("NSE_EQ|INE002A01018","CNC",100,5000);
    engine.routeOrder("UPSTOX", order);

    verify(adapter).placeOrder(order);
}

9. Frontend & CLI Support

Vite+React Autocomplete: queries MBAL /search?symbol=RELIANCE → returns instrument_key.

REST API: /order/place, /order/status, /portfolio (aggregated across brokers).

CLI: java -jar trader-cli.jar place-order --broker UPSTOX --symbol RELIANCE --qty 100.

10. Key Notes

Broker Agnostic: Adding a new broker only requires implementing BrokerAdapter.

Failover Ready: Orders can be re-routed if a broker API fails.

Unified Risk Enforcement: Client-level risk, session limits, intraday VaR applied across brokers.

Market Data Normalization: Each broker may use different symbol formats; MBAL normalizes them.