1. Database Schema (Normalized + Fast Lookup)
Design Goals

Immutable per trading day

Fast symbol → instrument_key lookup

Supports overlays (MIS / MTF / Suspended)

Forward compatible with schema evolution

1.1 Core Instruments Table
CREATE TABLE instruments (
    instrument_key      VARCHAR(64) PRIMARY KEY,
    segment             VARCHAR(16) NOT NULL,
    exchange            VARCHAR(8) NOT NULL,
    instrument_type     VARCHAR(8) NOT NULL,

    trading_symbol      VARCHAR(64) NOT NULL,
    name                VARCHAR(256),

    isin                VARCHAR(16),
    underlying_key      VARCHAR(64),
    underlying_symbol   VARCHAR(64),
    underlying_type     VARCHAR(16),

    expiry              TIMESTAMP NULL,
    strike_price        DECIMAL(10,2) DEFAULT 0,

    lot_size            INT NOT NULL,
    minimum_lot         INT,
    freeze_quantity     INT,

    tick_size           DECIMAL(6,2),
    exchange_token      VARCHAR(32),

    weekly              BOOLEAN DEFAULT FALSE,
    security_type       VARCHAR(16),

    trading_date        DATE NOT NULL,
    created_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

Indexes (Critical)
CREATE INDEX idx_symbol_type 
ON instruments (trading_symbol, segment, instrument_type);

CREATE INDEX idx_underlying 
ON instruments (underlying_key);

CREATE INDEX idx_expiry 
ON instruments (expiry);

1.2 Overlay Tables (Separation of Concerns)
Suspended Instruments
CREATE TABLE instrument_suspension (
    instrument_key VARCHAR(64) PRIMARY KEY,
    trading_date   DATE NOT NULL,
    reason         VARCHAR(256)
);

MTF Overlay
CREATE TABLE instrument_mtf (
    instrument_key VARCHAR(64) PRIMARY KEY,
    mtf_enabled    BOOLEAN,
    mtf_bracket    DECIMAL(5,2)
);

MIS Overlay
CREATE TABLE instrument_mis (
    instrument_key      VARCHAR(64) PRIMARY KEY,
    intraday_margin     DECIMAL(5,2),
    intraday_leverage   DECIMAL(5,2)
);

2. Java Loader (GZIP + Streaming + Indexing)
Design Principles

Streaming JSON (no full file load)

Idempotent per trading day

Crash-safe

Parallelizable

2.1 Loader Flow
Download → GZIP InputStream → Jackson Streaming → Batch Insert

2.2 Java Loader (Spring Boot Style)
InputStream gzipStream = new GZIPInputStream(
        new URL(INSTRUMENT_URL).openStream());

JsonFactory factory = new JsonFactory();
JsonParser parser = factory.createParser(gzipStream);

while (parser.nextToken() == JsonToken.START_OBJECT) {
    Instrument instrument = objectMapper.readValue(parser, Instrument.class);
    instrument.setTradingDate(LocalDate.now());
    repository.save(instrument);
}

Performance Enhancements

Use JDBC batch inserts (500–1000 rows)

Disable auto-commit

Use COPY for PostgreSQL if available

2.3 Daily Refresh Strategy
06:00 AM
↓
Load BOD
↓
Clear previous trading_date
↓
Apply overlays (MIS / MTF / Suspended)
↓
Mark system READY

3. Search API (Symbol → Instrument Key)
API Contract
GET /api/instruments/search

Query Parameters
Param	Purpose
symbol	Partial or full symbol
segment	NSE_EQ / NSE_FO
instrumentType	EQ / FUT / CE / PE
expiry	Optional
strike	Optional
3.1 Response Model
{
  "instrument_key": "NSE_EQ|INE002A01018",
  "trading_symbol": "RELIANCE",
  "segment": "NSE_EQ",
  "instrument_type": "EQ",
  "expiry": null,
  "strike_price": 0,
  "mtf_enabled": true,
  "intraday_allowed": true,
  "suspended": false
}

3.2 Query Logic (Pseudo-SQL)
SELECT i.*, 
       m.mtf_enabled, 
       mi.instrument_key IS NOT NULL AS intraday_allowed,
       s.instrument_key IS NOT NULL AS suspended
FROM instruments i
LEFT JOIN instrument_mtf m ON i.instrument_key = m.instrument_key
LEFT JOIN instrument_mis mi ON i.instrument_key = mi.instrument_key
LEFT JOIN instrument_suspension s ON i.instrument_key = s.instrument_key
WHERE i.trading_symbol ILIKE 'REL%'
AND i.segment = 'NSE_EQ'
AND i.instrument_type = 'EQ';

4. Frontend Autocomplete Architecture (Backend Perspective)
Backend Responsibility

Serve fast, filtered, ranked results

Stateless

Cache-friendly

4.1 Autocomplete API
GET /api/instruments/autocomplete?q=rel

Backend Optimization

Limit to 10–20 results

Prefer EQ over F&O

Rank:

Exact match

Prefix match

F&O after EQ

4.2 Caching Strategy
Redis:
Key: AUTO:NSE_EQ:REL
TTL: 10 minutes

5. Risk Engine View (MIS vs MTF vs CNC)

This is extremely important.

5.1 Product Types (Conceptual)
Product	Meaning	Risk Model
CNC	Delivery	Full margin
MIS	Intraday	Leverage + forced square-off
MTF	Carry forward with margin	Partial funding
5.2 Risk Decision Matrix
Check	CNC	MIS	MTF
Instrument allowed	BOD	MIS list	MTF list
Margin	100%	intraday_margin	mtf_bracket
Overnight	Yes	No	Yes
Square-off	No	Mandatory	Conditional
Leverage	None	High	Medium
5.3 Risk Engine Flow (Order Validation)
Order Received
↓
Fetch instrument_key
↓
Check suspended?
↓
Check product type:
    MIS → must exist in MIS table
    MTF → mtf_enabled = true
↓
Compute margin
↓
Allow / Reject

5.4 Margin Formula Examples
MIS
required_margin = LTP × qty × intraday_margin%

MTF
required_margin = (LTP × qty) / mtf_bracket

6. Recommended Microservice Boundaries
instrument-service
├── loader
├── search
├── autocomplete
├── risk-metadata


This service becomes read-only during market hours, which is ideal.

7. What This Enables Next

With this in place, you can:

Plug directly into Upstox MarketDataStreamer

Build option chain services

Compute Greeks correctly

Enforce risk rules centrally

Support multi-broker abstraction