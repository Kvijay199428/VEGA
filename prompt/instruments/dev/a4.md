Below is a clean, consolidated, Java-backend–only reference architecture, rewritten end-to-end with no ambiguity, no Python, and ready for Spring Boot + PostgreSQL + Redis.
This version incorporates instrument patterns, overlays, and risk semantics correctly.

1. Database Schema (Efficient + Correct)
1.1 Core Instrument Master (BOD Snapshot)

Design principles

Immutable per trading day

instrument_key is the only true identifier

Overlays are separated (MIS / MTF / Suspended)

CREATE TABLE instrument_master (
    instrument_key        VARCHAR(64) PRIMARY KEY,
    segment               VARCHAR(16) NOT NULL,
    exchange              VARCHAR(8) NOT NULL,
    instrument_type       VARCHAR(8) NOT NULL,

    trading_symbol        VARCHAR(64) NOT NULL,
    name                  VARCHAR(256),

    isin                  VARCHAR(16),
    underlying_key        VARCHAR(64),
    underlying_symbol     VARCHAR(64),
    underlying_type       VARCHAR(16),

    expiry                DATE,
    strike_price          DECIMAL(10,2),

    lot_size              INT NOT NULL,
    minimum_lot           INT,
    freeze_quantity       INT,

    tick_size             DECIMAL(6,2),
    exchange_token        VARCHAR(32),

    weekly                BOOLEAN,
    security_type         VARCHAR(16),

    trading_date          DATE NOT NULL,
    created_at            TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

Mandatory Indexes
CREATE INDEX idx_symbol_search
ON instrument_master (trading_symbol, segment, instrument_type);

CREATE INDEX idx_underlying
ON instrument_master (underlying_key);

CREATE INDEX idx_expiry
ON instrument_master (expiry);

1.2 Overlay Tables (Do NOT Merge These)
Suspended
CREATE TABLE instrument_suspension (
    instrument_key VARCHAR(64) PRIMARY KEY,
    trading_date   DATE NOT NULL
);

MIS (Intraday)
CREATE TABLE instrument_mis (
    instrument_key      VARCHAR(64) PRIMARY KEY,
    intraday_margin     DECIMAL(6,2),
    intraday_leverage   DECIMAL(6,2)
);

MTF (Carry Forward Margin)
CREATE TABLE instrument_mtf (
    instrument_key VARCHAR(64) PRIMARY KEY,
    mtf_enabled    BOOLEAN,
    mtf_bracket    DECIMAL(6,2)
);

2. Java Loader (GZIP + Streaming + Batch Insert)
2.1 Loader Rules

Streaming JSON (never load full file)

One trading day per load

Idempotent

Fail-safe

2.2 Java Loader (Jackson Streaming)
InputStream input = new GZIPInputStream(new URL(url).openStream());
JsonParser parser = new JsonFactory().createParser(input);

while (parser.nextToken() == JsonToken.START_OBJECT) {
    InstrumentEntity entity =
        objectMapper.readValue(parser, InstrumentEntity.class);
    entity.setTradingDate(LocalDate.now());
    batch.add(entity);

    if (batch.size() == 500) {
        repository.saveAll(batch);
        batch.clear();
    }
}
repository.saveAll(batch);

Performance Notes

Disable auto-commit

Batch size 500–1000

Separate loader per file (BOD, MIS, MTF, Suspended)

2.3 Daily Refresh Sequence
06:00 IST
↓
Truncate instrument_master (previous date)
↓
Load BOD
↓
Load Suspended
↓
Load MIS
↓
Load MTF
↓
Mark system READY

3. Search API (Symbol → Instrument Key)
3.1 REST Endpoint
GET /api/instruments/search

Parameters
Param	Required
symbol	Yes
segment	Yes
instrumentType	Yes
expiry	Optional
strike	Optional
3.2 Query (Authoritative)
SELECT i.instrument_key,
       i.trading_symbol,
       i.segment,
       i.instrument_type,
       i.expiry,
       i.strike_price,
       m.mtf_enabled,
       mi.instrument_key IS NOT NULL AS mis_allowed,
       s.instrument_key IS NOT NULL AS suspended
FROM instrument_master i
LEFT JOIN instrument_mtf m ON i.instrument_key = m.instrument_key
LEFT JOIN instrument_mis mi ON i.instrument_key = mi.instrument_key
LEFT JOIN instrument_suspension s ON i.instrument_key = s.instrument_key
WHERE i.trading_symbol ILIKE :symbol
AND i.segment = :segment
AND i.instrument_type = :type;

3.3 Response DTO
{
  "instrument_key": "NSE_EQ|INE002A01018",
  "symbol": "RELIANCE",
  "segment": "NSE_EQ",
  "instrument_type": "EQ",
  "mtf_enabled": true,
  "mis_allowed": true,
  "suspended": false
}

4. Frontend Autocomplete (Backend Design)
4.1 Endpoint
GET /api/instruments/autocomplete?q=rel

4.2 Ranking Rules

Exact match

Prefix match

EQ > FUT > OPT

NSE > BSE

4.3 Redis Cache
KEY: AUTO:NSE:REL
TTL: 10 minutes


Backend only returns:

instrument_key

trading_symbol

instrument_type

5. Risk Engine View (MIS vs MTF vs CNC)
5.1 Product Semantics
Product	Meaning	Holding
CNC	Delivery	Overnight allowed
MIS	Intraday	Forced square-off
MTF	Margin carry	Conditional carry
5.2 Validation Matrix
Rule	CNC	MIS	MTF
BOD instrument	Required	Required	Required
Suspended	Reject	Reject	Reject
MIS overlay	❌	Required	❌
MTF overlay	❌	❌	Required
Overnight	Allowed	❌	Allowed
5.3 Risk Validation Flow
Order → instrument_key
↓
Check suspended
↓
Switch(productType):
  MIS → exists in instrument_mis
  MTF → mtf_enabled = true
  CNC → allowed
↓
Calculate margin
↓
Approve / Reject

5.4 Margin Formulas
MIS
margin = LTP × qty × intraday_margin%

MTF
margin = (LTP × qty) / mtf_bracket

CNC
margin = LTP × qty

6. Service Boundary (Recommended)
instrument-reference-service
├── loader
├── search
├── autocomplete
├── risk-metadata


This service is:

Write-once per day

Read-heavy

Cache-friendly

Broker-agnostic

7. Final Engineering Rules (Non-Negotiable)

Persist only instrument_key

Never trust exchange_token

Never trade expired instruments

Never mix overlays into master

Never allow MIS overnight

Never compute margin without overlays