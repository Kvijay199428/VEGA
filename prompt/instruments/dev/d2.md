Next, we implement Auction / Call Market Handling. This ensures that the Risk Management System (RMS) enforces proper trading rules during pre-open, call, and auction sessions. It integrates with the Intraday VaR Throttling and Client-Level Risk Limits modules, while respecting session-specific restrictions.

MODULE 3 — AUCTION / CALL MARKET HANDLING
1. Overview

Handles pre-open, call, auction, and closing sessions for NSE/BSE.

Integrates with RMS for risk checks during session-specific order acceptance.

Enforces no market orders or quantity limits during pre-open.

Allows price discovery only through auction mechanisms.

Supports MIS / MTF / CNC order segregation per session.

2. Database Layer (Flyway)
V17__market_session_config.sql
CREATE TABLE market_sessions (
    session_id       TEXT PRIMARY KEY,
    exchange         TEXT NOT NULL,
    start_time       INTEGER NOT NULL,
    end_time         INTEGER NOT NULL,
    session_type     TEXT NOT NULL, -- PRE_OPEN, CALL, AUCTION, REGULAR, CLOSING
    allowed_products TEXT NOT NULL -- CSV: CNC,MIS,MTF
);

V18__session_order_limits.sql
CREATE TABLE session_order_limits (
    session_id      TEXT NOT NULL,
    client_id       TEXT,
    max_qty         INTEGER,
    max_value       REAL,
    PRIMARY KEY(session_id, client_id)
);

3. Domain Models
MarketSession.java
public record MarketSession(
    String sessionId,
    String exchange,
    long startTime,
    long endTime,
    String sessionType,
    Set<String> allowedProducts
) {}

SessionOrderLimit.java
public record SessionOrderLimit(
    String sessionId,
    String clientId,
    int maxQty,
    double maxValue
) {}

4. DAO Layer
MarketSessionDao.java
public interface MarketSessionDao {
    MarketSession findCurrentSession(String exchange, long timestamp);
    List<MarketSession> listSessions(String exchange);
}

SessionOrderLimitDao.java
public interface SessionOrderLimitDao {
    SessionOrderLimit find(String sessionId, String clientId);
}

5. Session Engine
MarketSessionEngine.java
public class MarketSessionEngine {

    private final MarketSessionDao sessionDao;
    private final SessionOrderLimitDao limitDao;

    public MarketSessionEngine(MarketSessionDao sessionDao, SessionOrderLimitDao limitDao) {
        this.sessionDao = sessionDao;
        this.limitDao = limitDao;
    }

    public void validateOrder(String exchange, String clientId, String product, int qty, double value, long timestamp) {
        MarketSession session = sessionDao.findCurrentSession(exchange, timestamp);
        if (session == null) {
            throw new RiskReject("NO_ACTIVE_SESSION");
        }

        // Product-level restriction
        if (!session.allowedProducts().contains(product)) {
            throw new RiskReject("PRODUCT_NOT_ALLOWED_IN_SESSION");
        }

        // Client-level session order limits
        SessionOrderLimit limit = limitDao.find(session.sessionId(), clientId);
        if (limit != null) {
            if (qty > limit.maxQty()) {
                throw new RiskReject("QTY_EXCEEDS_SESSION_LIMIT");
            }
            if (value > limit.maxValue()) {
                throw new RiskReject("VALUE_EXCEEDS_SESSION_LIMIT");
            }
        }

        // Additional session type enforcement
        switch (session.sessionType()) {
            case "PRE_OPEN", "CALL", "AUCTION":
                // Only limit orders allowed, no market orders
                if (product.equals("MTF")) { 
                    // Example: restrict market orders during pre-open
                    throw new RiskReject("MARKET_ORDER_NOT_ALLOWED_IN_SESSION");
                }
                break;
            default:
                break;
        }
    }
}

6. Integration with RMS
Order Request
  → ClientRiskEvaluator
  → IntradayVarEngine
  → MarketSessionEngine (session-specific checks)
  → FO Rollover / Trade-for-Trade / Dynamic Price Band checks
  → Broker Adapter

7. Use Cases
Scenario	Behavior
Pre-open session, CNC order	Limit order allowed if under session limit
Pre-open session, MTF market order	Rejected
Call / Auction session	Only eligible products allowed, enforce session limits
Regular session	No restrictions (RMS applies standard checks)
Closing session	Same as regular or restricted per exchange config
8. Unit Test Example (SQLite In-Memory)
@Test
void rejectMarketOrderDuringPreOpen() {
    long now = System.currentTimeMillis();
    MarketSession session = new MarketSession("S1","NSE", now-1000, now+10000,"PRE_OPEN", Set.of("CNC","MIS"));
    when(sessionDao.findCurrentSession("NSE", now)).thenReturn(session);

    assertThrows(RiskReject.class, () -> engine.validateOrder("NSE","C1","MTF",100, 50000, now));
}

Key Notes

Supports Multiple Exchanges: NSE / BSE session types handled.

Dynamic Limits: Session-level order caps configurable per client.

Seamless Integration: Works with Intraday VaR, CNC/MIS/MTF segregation.

Fail-Safe Mode: If no session config found, reject all orders by default.