Sectoral Indexing – Implementation Proceed Plan (Enterprise-Grade)

This proceeds from schema → ingestion → services → APIs → frontend → risk → testing in the correct dependency order.

1. Database Migrations (Flyway)
V27__sector_master.sql
CREATE TABLE sector_master (
  sector_code TEXT PRIMARY KEY,
  sector_name TEXT NOT NULL,
  category TEXT NOT NULL, -- BROAD | SECTORAL | THEMATIC
  active BOOLEAN DEFAULT 1,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

V28__index_master.sql
CREATE TABLE index_master (
  index_code TEXT PRIMARY KEY,
  index_name TEXT NOT NULL,
  sector_code TEXT,
  source_url TEXT NOT NULL,
  exchange TEXT DEFAULT 'NSE',
  active BOOLEAN DEFAULT 1,
  last_updated DATE,
  FOREIGN KEY (sector_code) REFERENCES sector_master(sector_code)
);

V29__index_constituent.sql
CREATE TABLE index_constituent (
  index_code TEXT NOT NULL,
  instrument_key TEXT NOT NULL,
  symbol TEXT NOT NULL,
  series TEXT NOT NULL,
  isin TEXT,
  industry TEXT,
  weight REAL,
  as_of_date DATE DEFAULT CURRENT_DATE,
  PRIMARY KEY (index_code, instrument_key),
  FOREIGN KEY (index_code) REFERENCES index_master(index_code)
);

V30__instrument_sector_view.sql
CREATE VIEW instrument_sector_view AS
SELECT DISTINCT
  ic.instrument_key,
  im.sector_code,
  sm.sector_name,
  im.index_code,
  im.index_name
FROM index_constituent ic
JOIN index_master im ON ic.index_code = im.index_code
JOIN sector_master sm ON im.sector_code = sm.sector_code;

2. Java Domain Layer
Entities
rms/sector/
├── SectorEntity.java
├── IndexEntity.java
├── IndexConstituentEntity.java


Key design rule:

No duplication of InstrumentMaster

instrument_key is always authoritative

Repositories
rms/sector/repository/
├── SectorRepository.java
├── IndexRepository.java
├── IndexConstituentRepository.java


All repositories must support:

upsert

findBySector

findByIndex

3. Index Ingestion (Core Feature)
3.1 Index Registry (Config-Driven)

config/index-registry.yml

indices:
  - indexCode: NIFTY_IT
    indexName: Nifty IT
    sector: IT
    category: SECTORAL
    url: https://www.niftyindices.com/IndexConstituent/ind_niftyitlist.csv

  - indexCode: NIFTY_BANK
    indexName: Nifty Bank
    sector: BANKING
    category: SECTORAL
    url: https://www.niftyindices.com/IndexConstituent/ind_niftybanklist.csv


➡️ Adding future sectors = add YAML only

3.2 IndexConstituentLoader (Java)
rms/sector/loader/
└── IndexConstituentLoader.java


Core responsibilities:

Download CSV

Parse rows

Resolve instrument_key

Upsert constituents

Update last_updated

Instrument Key Resolution (Canonical)
instrumentKey = "NSE_EQ|" + symbol;


Validation:

Must exist in instrument_master

Series must be allowed by RMS (EQ / SME / BE)

Rejected rows are logged, not fatal.

3.3 CLI Entry
java -jar vega-trader.jar load-indices --all
java -jar vega-trader.jar load-indices --index NIFTY_IT

4. InstrumentService Integration
New Queries
InstrumentService
├── findBySector(sectorCode)
├── findByIndex(indexCode)
├── search(q, sector?, index?)


Query path:

instrument_master
 → instrument_sector_view
 → index_constituent

5. REST API Extensions
5.1 Sector Metadata
GET /api/sectors


Response:

[
  { "code": "IT", "name": "Information Technology" },
  { "code": "BANKING", "name": "Banking & Finance" }
]

5.2 Index Metadata
GET /api/indices?sector=IT

5.3 Instrument Search (Enhanced)
GET /api/instruments/search?q=infy&sector=IT


Supports:

Symbol

Sector

Index

Industry

6. Frontend (Vite + React)
UI Controls

Sector dropdown

Index multiselect

Search box (debounced)

Autocomplete Ranking

Symbol exact

Sector membership

Index membership

Industry match

UX Example

Typing bank:

Axis Bank

HDFC Bank

Nifty Bank constituents

7. RMS & Risk Engine Extensions
7.1 Sector Exposure Limits (Optional)
CREATE TABLE sector_risk_limit (
  sector_code TEXT PRIMARY KEY,
  max_notional DECIMAL,
  max_positions INTEGER
);

Enforcement Hook
RmsValidationService
 → resolve sector
 → evaluate exposure
 → reject if breached

7.2 Sector Kill-Switch
if (sector.isBlocked()) {
  throw new RiskRejectException("SECTOR_BLOCKED");
}

8. Caching Strategy

Cache:

Sector → instruments

Index → instruments

TTL: Daily

Evict on:

Index reload

RMS config change

9. Testing Plan (Mandatory)
Unit Tests

CSV parsing

Instrument key resolution

Sector mapping

Integration Tests

Search by sector

RMS sector rejection

Regression Tests

Existing instrument search unaffected

Broker routing unchanged

10. Operational Guarantees
Capability	Status
Add new sectors via URL	✅
Historical reproducibility	✅
RMS compatibility	✅
Multi-broker safe	✅
Zero downtime updates	✅
11. Why This Design Is Correct

Instrument master remains authoritative

Sector is a derived, auditable classification

Fully compliant with exchange data sources

Scales to:

100+ indices

Broker-specific baskets

Client-specific universes