Below is the exact Java-side implementation guide for the Sectoral Indexing feature, aligned with your existing Instruments + RMS + Multi-Broker architecture.
This is written so you can directly code and integrate, not just document.

Sectoral Indexing – Java Implementation Guide

This section answers how it actually works in code.

1. Where Sector Data Lives (Authoritative Answer)

Instrument data is NOT constructed dynamically at runtime.

Source of truth
Data	Source
Instrument key	instrument_master (existing)
Sector / Index membership	index_constituent (new)
Sector metadata	sector_master
Index metadata	index_master

➡ Sector is a classification overlay, not a new instrument.

2. Java Package Layout (Final)
rms/
 └── sector/
     ├── entity/
     │   ├── SectorEntity.java
     │   ├── IndexEntity.java
     │   ├── IndexConstituentEntity.java
     │
     ├── repository/
     │   ├── SectorRepository.java
     │   ├── IndexRepository.java
     │   ├── IndexConstituentRepository.java
     │
     ├── loader/
     │   ├── IndexRegistry.java
     │   ├── IndexConstituentLoader.java
     │
     ├── service/
     │   ├── SectorService.java
     │   ├── IndexService.java
     │   ├── SectorInstrumentResolver.java

3. Entity Definitions (Exact)
SectorEntity.java
@Entity
@Table(name = "sector_master")
public class SectorEntity {

    @Id
    private String sectorCode;

    private String sectorName;

    @Enumerated(EnumType.STRING)
    private SectorCategory category; // BROAD, SECTORAL, THEMATIC

    private boolean active;
}

IndexEntity.java
@Entity
@Table(name = "index_master")
public class IndexEntity {

    @Id
    private String indexCode;

    private String indexName;
    private String sectorCode;
    private String sourceUrl;
    private String exchange;
    private LocalDate lastUpdated;
}

IndexConstituentEntity.java
@Entity
@Table(name = "index_constituent")
@IdClass(IndexConstituentId.class)
public class IndexConstituentEntity {

    @Id
    private String indexCode;

    @Id
    private String instrumentKey;

    private String symbol;
    private String series;
    private String isin;
    private String industry;
}

4. Index Registry (Config Driven – Key Feature)
index-registry.yml
indices:
  - indexCode: NIFTY_IT
    indexName: Nifty IT
    sector: IT
    category: SECTORAL
    url: https://www.niftyindices.com/IndexConstituent/ind_niftyitlist.csv

IndexRegistry.java
@Component
@ConfigurationProperties(prefix = "indices")
public class IndexRegistry {
    private List<IndexConfig> indices;
}


➡ Future indices = YAML only
No code changes.

5. Index Constituent Loader (Core Logic)
Instrument Key Resolution Rule (Critical)
String instrumentKey = "NSE_EQ|" + csvSymbol;


Validation Steps

Exists in instrument_master

Series allowed (EQ, SM, BE)

Not expired

Not delisted

Rejected rows:

Logged

Stored in audit table (optional)

Do NOT break ingestion

IndexConstituentLoader.java
@Transactional
public void load(IndexConfig config) {

    List<CsvRow> rows = csvDownloader.download(config.getUrl());

    for (CsvRow row : rows) {
        String instrumentKey = "NSE_EQ|" + row.getSymbol();

        if (!instrumentMasterRepo.exists(instrumentKey)) {
            log.warn("Missing instrument {}", instrumentKey);
            continue;
        }

        repository.upsert(new IndexConstituentEntity(
            config.getIndexCode(),
            instrumentKey,
            row.getSymbol(),
            row.getSeries(),
            row.getIsin(),
            row.getIndustry()
        ));
    }
}

6. Instrument Lookup Flow (Your Question Answered Clearly)
When user searches for an instrument key
Frontend search
 → REST /api/instruments/search
 → InstrumentService
 → instrument_master (base)
 → instrument_sector_view (sector/index overlay)

Important Clarification

❌ Instrument key is NOT constructed dynamically
❌ Instrument key is NOT fetched from broker
✅ Instrument key is stored once and reused everywhere

Sector lookup never modifies instrument identity.

7. Sector-Based Search (New Capability)
API
GET /api/instruments/search?q=bank&sector=BANKING

Query Logic
SELECT im.*
FROM instrument_master im
JOIN instrument_sector_view sv
  ON im.instrument_key = sv.instrument_key
WHERE sv.sector_code = :sector
AND im.symbol LIKE :q;

8. RMS Integration (Where Sector Matters)
Used by:
RMS Feature	Sector Used
Eligibility cache	✅
Intraday margin	Optional
Sector exposure limits	Optional
Kill-switch	Optional

Sector is never mandatory for order placement.

9. Broker Layer (Unaffected)

Brokers receive instrument_key

Sector is never sent to broker

Broker adapters remain unchanged

This preserves:

Upstox compatibility

Multi-broker neutrality

10. Testing Strategy (Executable)
Unit Tests
IndexConstituentLoaderTest
SectorInstrumentResolverTest

Integration Tests
Search by sector
Search by index
Fallback to symbol-only search

Regression Guarantee

Existing instrument search must pass unchanged

11. Documentation Sections You Will Create Later

This implementation enables you to document:

Sector ingestion lifecycle

Instrument identity rules

Search ranking logic

RMS enforcement points

Operational SOP (cron-based reload)