Here’s the next logical step: a sequence diagram + service interface design for expired instruments and historical data fetch. This will make it enterprise-grade, testable, and consistent across CLI, REST, and frontend.

1. Expired Instruments Flow – Sequence Diagram (Mermaid)
sequenceDiagram
    participant CLI
    participant Frontend
    participant REST_API
    participant ExpiredInstrumentService
    participant InstrumentService
    participant UpstoxAPI
    participant MarketDataService
    participant Cache

    CLI->>REST_API: Request historical candles for expired instrument
    Frontend->>REST_API: Request historical candles (via UI search)
    REST_API->>InstrumentService: Validate underlying instrument_key
    InstrumentService-->>REST_API: Validated key
    REST_API->>Cache: Check expiry dates cache
    Cache-->>REST_API: Cached expiry list (if exists)
    REST_API->>ExpiredInstrumentService: Fetch expiries (if cache miss)
    ExpiredInstrumentService->>UpstoxAPI: GET /expired-instruments/expiries
    UpstoxAPI-->>ExpiredInstrumentService: Expiry list
    ExpiredInstrumentService->>Cache: Store expiry list
    ExpiredInstrumentService-->>REST_API: Return expiry list
    REST_API->>ExpiredInstrumentService: Resolve expired contracts
    ExpiredInstrumentService->>UpstoxAPI: GET /expired-instruments/option|future/contract
    UpstoxAPI-->>ExpiredInstrumentService: Contract list
    ExpiredInstrumentService-->>MarketDataService: Construct expired_instrument_key & fetch candles
    MarketDataService->>UpstoxAPI: GET /expired-instruments/historical-candle
    UpstoxAPI-->>MarketDataService: OHLC + OI data
    MarketDataService-->>REST_API: Normalized candle data
    REST_API-->>CLI: JSON response
    REST_API-->>Frontend: JSON response

2. Java Service Interfaces (Enterprise-Grade)
public interface ExpiredInstrumentService {

    /**
     * Fetch all expiries for an underlying instrument
     */
    List<LocalDate> fetchExpiries(String underlyingKey);

    /**
     * Fetch expired option contracts for a given expiry
     */
    List<ExpiredOptionContract> fetchExpiredOptions(String underlyingKey, LocalDate expiry);

    /**
     * Fetch expired future contracts for a given expiry
     */
    List<ExpiredFutureContract> fetchExpiredFutures(String underlyingKey, LocalDate expiry);

    /**
     * Construct the expired instrument key
     */
    String buildExpiredInstrumentKey(String instrumentKey, LocalDate expiry);

}

public interface MarketDataService {

    /**
     * Fetch OHLC+OI historical data for expired instruments
     */
    List<Candle> fetchExpiredHistoricalCandles(String expiredInstrumentKey,
                                               String interval,
                                               LocalDate fromDate,
                                               LocalDate toDate);
}

3. DTOs / Models
public record ExpiredOptionContract(
    String instrumentKey,
    String tradingSymbol,
    String instrumentType,
    double strikePrice,
    int lotSize,
    String underlyingKey,
    LocalDate expiry
) {}

public record ExpiredFutureContract(
    String instrumentKey,
    String tradingSymbol,
    int lotSize,
    String underlyingKey,
    LocalDate expiry
) {}

public record Candle(
    ZonedDateTime timestamp,
    double open,
    double high,
    double low,
    double close,
    long volume,
    long openInterest
) {}

4. Caching Strategy
Layer	What to Cache	TTL	Notes
Expiries	List of expiry dates per underlying	24h	Reduce repeated API calls
Expired Contracts	Option / Future contracts per expiry	12h	Optional, heavy for backtesting
Historical Candles	Candles per expired instrument	1 week	Optional, read-only

Use Redis or in-memory cache. No database persistence needed for expired instrument metadata.

5. CLI / REST / Frontend Mapping
Interface	Flow
CLI	Calls REST API with underlying + expiry + interval
REST API	Delegates to ExpiredInstrumentService + MarketDataService
Frontend	Calls REST API via search/filter UI
Curl / Scripts	Direct REST API access with same parameters

All interfaces share common service layer. Ensures DRY and consistency.

6. Testing Strategy (JUnit + Integration)

Unit Tests

Expired instrument key construction

Regex validation for keys

Interval validation

Integration Tests

Expiry fetch → mock Upstox API

Contract fetch → mock Upstox API

Candle fetch → validate JSON schema

Negative Tests

Invalid instrument key

Invalid expiry

Invalid interval

MCX expiry request (unsupported)