Below is a full implementation guide that you can directly translate into code, migrations, tests, diagrams, and final documentation.
It is structured exactly the way an enterprise trading system spec would be written, and it aligns 1:1 with your current RMS + Instruments + Broker architecture.

1. Expiry Logic – Formalized Implementation
1.1 Objective

Provide a deterministic, exchange-aware, future-proof expiry engine that:

Works for NSE and BSE

Supports weekly, monthly, quarterly, half-yearly

Handles holiday fallbacks

Is broker-agnostic

1.2 Core Concepts
Expiry Dimensions
Dimension	Description
Exchange	NSE / BSE
Segment	FO
Instrument Type	FUTIDX / OPTIDX / FUTSTK / OPTSTK
Cycle Type	WEEKLY / MONTHLY / QUARTERLY / HALF_YEARLY
Expiry Day	TUE (NSE) / THU (BSE)
Fallback Rule	Previous trading day
1.3 SQL Migrations (Expiry)
CREATE TABLE exchange_expiry_rule (
  exchange              VARCHAR(10) NOT NULL,
  instrument_type       VARCHAR(20) NOT NULL,
  cycle_type             VARCHAR(20) NOT NULL,
  expiry_day             VARCHAR(10) NOT NULL,
  fallback_strategy      VARCHAR(30) NOT NULL,
  active                 BOOLEAN DEFAULT TRUE,
  PRIMARY KEY (exchange, instrument_type, cycle_type)
);

Seed Data
INSERT INTO exchange_expiry_rule VALUES
('NSE','OPTIDX','WEEKLY','TUESDAY','PREVIOUS_TRADING_DAY',true),
('NSE','OPTIDX','MONTHLY','TUESDAY','PREVIOUS_TRADING_DAY',true),
('BSE','OPTIDX','MONTHLY','THURSDAY','PREVIOUS_TRADING_DAY',true);

1.4 Java Service Skeleton
public interface ExpiryCalendarService {
    LocalDate resolveExpiry(
        String exchange,
        InstrumentType instrumentType,
        CycleType cycleType,
        YearMonth contractMonth
    );
}

@Service
public class ExpiryCalendarServiceImpl implements ExpiryCalendarService {

    @Override
    public LocalDate resolveExpiry(...) {
        LocalDate candidate = calculateByRule();
        return tradingCalendar.adjust(candidate);
    }
}

1.5 RMS Integration Point
OrderRequest
 → InstrumentMaster
 → ExpiryCalendarService
 → FoContractLifecycleEntity
 → RMS Validation

2. Strike Rules – Scheduler-Based Enforcement
2.1 Objective

Ensure only valid, liquid strikes are tradable, per exchange rules.

2.2 Rules to Encode
NSE Option Strike Review Rule
IF strike NOT in current strike_scheme AND OI == 0 → DISABLE
IF strike NOT in scheme AND OI > 0 → KEEP ENABLED


This must never be evaluated at order time.

2.3 SQL Migrations (Strike Rules)
CREATE TABLE strike_scheme_rule (
  exchange          VARCHAR(10),
  underlying        VARCHAR(50),
  strike_interval   INTEGER,
  review_frequency  VARCHAR(20),
  PRIMARY KEY (exchange, underlying)
);

2.4 Scheduler Skeleton
@Scheduled(cron = "0 30 18 * * ?")
public void enforceStrikeRules() {
    List<Strike> strikes = strikeRepository.findAll();
    for (Strike s : strikes) {
        if (!isInScheme(s) && s.getOpenInterest() == 0) {
            s.disable();
        }
    }
}

2.5 RMS Behavior
Condition	RMS Action
Strike disabled	REJECT
Strike active	Continue
3. BSE Special Cases – Formal Mapping
3.1 Objective

Translate BSE market structure into RMS-enforceable logic.

3.2 BSE Group Mapping
SQL
CREATE TABLE bse_group_rule (
  group_code      VARCHAR(5),
  cnc_only        BOOLEAN,
  trade_for_trade BOOLEAN,
  quantity_cap    INTEGER,
  PRIMARY KEY (group_code)
);

Example
INSERT INTO bse_group_rule VALUES
('T',true,true,1000),
('Z',true,false,500),
('X',false,false,2000);

3.3 RMS Enforcement
if (bseGroup.isTradeForTrade()) {
    enforceNoIntradayNetting();
}

4. RMS Rejection Codes (STANDARDIZED)
4.1 Why This Matters

Broker-agnostic error handling

Clear audit logs

Documentation-grade clarity

4.2 Rejection Code Table
CREATE TABLE rms_rejection_code (
  code           VARCHAR(30) PRIMARY KEY,
  category       VARCHAR(30),
  description    VARCHAR(255)
);

Seed Data
Code	Meaning
RMS_EXPIRY_INVALID	Expired / Invalid expiry
RMS_STRIKE_DISABLED	Strike disabled
RMS_PRICE_BAND	Price outside band
RMS_QTY_CAP	Quantity exceeds cap
RMS_BSE_T2T	Trade-for-trade violation
RMS_CLIENT_LIMIT	Client limit breached
4.3 Java Enum
public enum RmsRejectCode {
    RMS_EXPIRY_INVALID,
    RMS_STRIKE_DISABLED,
    RMS_PRICE_BAND,
    RMS_QTY_CAP,
    RMS_BSE_T2T,
    RMS_CLIENT_LIMIT
}

5. Sequence Diagram (PlantUML)
@startuml
actor Trader
participant Frontend
participant REST_API
participant EligibilityCache
participant RmsValidationService
participant ClientRiskEvaluator
participant MultiBrokerEngine
participant UpstoxAdapter

Trader -> Frontend : Place Order
Frontend -> REST_API : OrderRequest
REST_API -> EligibilityCache : Check eligibility
EligibilityCache --> REST_API : OK
REST_API -> RmsValidationService : Validate order
RmsValidationService -> ClientRiskEvaluator : Risk check
ClientRiskEvaluator --> RmsValidationService : PASS
RmsValidationService --> REST_API : PASS
REST_API -> MultiBrokerEngine : Route order
MultiBrokerEngine -> UpstoxAdapter : Place order
UpstoxAdapter --> MultiBrokerEngine : BrokerResponse
MultiBrokerEngine --> REST_API : OrderStatus
REST_API --> Frontend : Final status
@enduml

6. Documentation-Ready Sections (Final Output)

You should structure your documentation as:

6.1 Instruments Overview

Instrument master

Exchange coverage

Lifecycle

6.2 Expiry Engine

Rules per exchange

Fallback logic

Examples

6.3 Strike Management

Strike scheme ingestion

Daily enforcement

RMS impact

6.4 RMS Validation Matrix

Price band

Quantity cap

Client risk

Exchange-specific rules

6.5 Broker Abstraction

Adapter responsibilities

Error normalization

Order lifecycle

6.6 Error & Rejection Handling

RMS codes

Broker errors

User-facing messages

7. What You Should Do Next (Concrete)

Add migrations listed above

Implement service skeletons (no logic shortcuts)

Add scheduler

Freeze schemas

Write JUnit tests per rule

Generate diagrams

Start documentation

Bottom Line

This guide:

Completes your instrument intelligence layer

Makes RMS exchange-compliant

Keeps broker abstraction clean

Is documentation-ready without rewriting