Below is a production-grade extension of your existing Instruments + Broker architecture.
Everything is incremental, backward-compatible, and documentation-ready.

I will cover each requested item in execution order, with clear ownership boundaries, SQL, Java skeletons, RMS implications, and operational behavior.

1. Batch Pre-Warm Scheduler (T-1 Expiry)
1.1 Why This Exists (Architectural Justification)

Problem:

Broker APIs are rate-limited

First order on expiry morning should never block on contract discovery

Solution:

Pre-resolve broker contracts one trading day before expiry

Populate DB + cache proactively

Ownership:

Instruments / Broker layer

NOT RMS

NOT Order flow

1.2 Scheduler Responsibilities

Runs daily EOD

Identifies:

Contracts expiring T+1

Active underlyings

Allowed strikes (after disablement logic)

Calls BrokerResolver in batch mode

1.3 Java Scheduler Skeleton
@Component
public class BrokerInstrumentPrewarmJob {

    private final InstrumentQueryService instrumentQueryService;
    private final MultiBrokerResolver multiBrokerResolver;

    @Scheduled(cron = "0 30 18 * * MON-FRI") // 6:30 PM IST
    public void prewarmTomorrowExpiry() {

        LocalDate targetExpiry = TradingCalendar.nextTradingDay(LocalDate.now());

        List<OptionDescriptor> options =
                instrumentQueryService.findOptionsByExpiry(targetExpiry);

        options.forEach(option ->
                multiBrokerResolver.resolveAcrossBrokers(option)
        );
    }
}

1.4 Query Contract
public record OptionDescriptor(
        String underlyingKey,
        LocalDate expiry,
        BigDecimal strike,
        OptionType optionType
) {}

1.5 Failure Policy
Scenario	Behavior
Broker timeout	Logged, retried next cycle
Partial failure	Allowed
Total failure	Alert only
Order flow impact	NONE
2. Multi-Broker Resolver Fan-Out
2.1 Why Fan-Out is Needed

Your current adapter is single-broker aware.
We now elevate this to broker-agnostic resolution.

2.2 Core Rule

RMS approves instrument semantics
Broker resolver selects tradable identity per broker

2.3 Resolver Interface
public interface BrokerResolver {

    BrokerInstrument resolve(
            Broker broker,
            OptionDescriptor descriptor
    );
}

2.4 Fan-Out Engine
@Service
public class MultiBrokerResolver {

    private final Map<Broker, BrokerInstrumentResolver> resolvers;

    public void resolveAcrossBrokers(OptionDescriptor descriptor) {

        for (Broker broker : Broker.enabled()) {
            try {
                resolvers.get(broker)
                        .resolveOptionContract(
                                descriptor.underlyingKey(),
                                descriptor.expiry(),
                                descriptor.strike(),
                                descriptor.optionType()
                        );
            } catch (Exception ex) {
                log.warn("Prewarm failed for broker {}", broker, ex);
            }
        }
    }
}

2.5 Order Flow Usage
BrokerInstrument instrument =
        brokerResolver.resolve(
                order.getBroker(),
                order.getOptionDescriptor()
        );


No broker branching anywhere else.

3. Contract Versioning (Critical for Regulatory Changes)
3.1 Why Versioning Is Mandatory

NSE expiry day revisions

Strike interval changes

Freeze quantity updates

Broker re-tokenization

Old contracts must not disappear.

3.2 SQL Migration
ALTER TABLE broker_symbol_mapping
ADD COLUMN contract_version INT NOT NULL DEFAULT 1;

ALTER TABLE broker_symbol_mapping
ADD COLUMN valid_from DATE NOT NULL DEFAULT CURRENT_DATE;

ALTER TABLE broker_symbol_mapping
ADD COLUMN valid_to DATE NULL;

3.3 Versioning Rule
Event	Action
Strike interval change	New version
Expiry revision	New version
Freeze quantity change	New version
Token change	New version

Old rows:

active = false

valid_to = today

3.4 Resolver Query Rule
WHERE active = true
AND valid_from <= CURRENT_DATE
AND (valid_to IS NULL OR valid_to >= CURRENT_DATE)

3.5 Entity Extension
private int contractVersion;
private LocalDate validFrom;
private LocalDate validTo;

4. Strike Disablement Logic (Exchange-Driven)
4.1 Source of Truth

From NSE circular:

Disable strikes:

Not in strike scheme

AND open interest = 0

Review:

Monthly

After expiry EOD

Effective T+2

4.2 Ownership
Layer	Responsibility
Instruments	Compute eligibility
RMS	Enforce rejection
Broker	NEVER decides
4.3 SQL Table
CREATE TABLE disabled_strikes (
    underlying_key VARCHAR(64),
    expiry DATE,
    strike NUMERIC(10,2),
    option_type VARCHAR(2),
    disabled_reason VARCHAR(64),
    disabled_from DATE,
    PRIMARY KEY (underlying_key, expiry, strike, option_type)
);

4.4 Strike Evaluation Job
@Component
public class StrikeDisablementJob {

    @Scheduled(cron = "0 0 22 1 * ?") // Monthly
    public void evaluate() {

        List<StrikeOI> oiData = oiService.fetch();

        oiData.stream()
              .filter(this::isNotInStrikeScheme)
              .filter(oi -> oi.getOpenInterest() == 0)
              .forEach(this::disableStrike);
    }
}

4.5 RMS Enforcement
if (strikeDisabledRepository.exists(descriptor)) {
    throw new RmsRejectException(
        "RMS-STRIKE-004",
        "Strike disabled by exchange"
    );
}

5. RMS Rejection Codes (Extended)
Code	Description
RMS-INS-001	Instrument expired
RMS-INS-002	Invalid strike
RMS-INS-003	Invalid expiry
RMS-STRIKE-004	Strike disabled
RMS-BKR-001	Broker contract missing
RMS-BKR-002	Broker unavailable
6. Sequence Diagram – Full Order Flow
@startuml
participant UI
participant API
participant RMS
participant StrikeService
participant BrokerResolver
participant BrokerAPI

UI -> API : Place Order
API -> RMS : Validate
RMS -> StrikeService : Check strike eligibility
StrikeService --> RMS : OK
RMS -> BrokerResolver : Resolve contract
BrokerResolver -> BrokerResolver : Cache/DB
BrokerResolver -> BrokerAPI : Fetch (if needed)
BrokerAPI --> BrokerResolver : Instrument
BrokerResolver --> RMS : BrokerInstrument
RMS --> API : Approved
API --> UI : Order Accepted
@enduml

7. Documentation-Ready Sections
Instrument Lifecycle Management

Exchange rules are materialized, not inferred

Broker APIs are resolution layers only

Versioning ensures historical integrity

Disablement rules strictly follow exchange circulars

8. Operational Guarantees
Guarantee	Status
Cold-start safety	✅
Broker outage tolerance	✅
Regulatory adaptability	✅
Auditability	✅
Multi-exchange readiness	✅
9. What You Should Do Next (Recommended)

Add OI ingestion job

Add calendar-aware trading day resolver

Generate OpenAPI spec

Start documentation phase