Below is a production-grade continuation of the same architecture, covering testing, lifecycle accounting, P&L linkage, and regulator-ready exports, written exactly as it would appear in an enterprise internal implementation + compliance handbook.

No assumptions are made beyond what you have already built.

11. JUnit + WireMock: Persistence & Broker Contract Testing
11.1 Test Objectives

These tests must prove to auditors and reviewers that:

Orders are persisted only after broker ACK

Charges are deterministic and reproducible

Cache and DB states are eventually consistent

Failure scenarios do not corrupt audit data

11.2 WireMock Setup (Broker Simulation)
@RegisterExtension
static WireMockExtension wireMock = WireMockExtension.newInstance()
    .options(wireMockConfig().dynamicPort())
    .build();

Stub Broker Order ACK
wireMock.stubFor(post("/broker/order")
    .willReturn(okJson("""
    {
      "order_id": "BRK123",
      "status": "ACKNOWLEDGED",
      "timestamp": "2025-01-10T10:15:30Z"
    }
    """)));

11.3 Persistence Test (Core)
@Test
void order_is_persisted_after_ack() {
    OrderResult result = placeOrder();

    OrderEntity entity =
        orderRepository.findByOrderId(result.getOrderId());

    assertThat(entity).isNotNull();
    assertThat(entity.getBrokerOrderId()).isEqualTo("BRK123");
}

11.4 Charges Integrity Test
@Test
void charges_are_computed_and_stored() {
    OrderCharges charges =
        chargesRepository.findByOrderId(orderId);

    assertThat(charges.getTotalCharges())
        .isEqualTo(
            charges.getBrokerage()
            .add(charges.getGst())
            .add(charges.getExchangeTxnCharge())
        );
}

11.5 Cache vs DB Consistency Test
@Test
void cache_matches_database() {
    OrderEntity dbOrder = orderRepository.findByOrderId(orderId);
    OrderEntity cacheOrder = redis.get("order:" + orderId);

    assertThat(cacheOrder).usingRecursiveComparison()
        .isEqualTo(dbOrder);
}

12. Order Modification & Cancellation Accounting

Key regulatory rule

An order modification or cancellation is a NEW FINANCIAL EVENT, not an update.

12.1 Order Lifecycle Model
NEW → ACKNOWLEDGED → MODIFIED* → TRADED → SETTLED
                   → CANCELLED

12.2 Database Extension
order_events table
CREATE TABLE order_events (
  id BIGSERIAL PRIMARY KEY,
  order_id VARCHAR(64),
  event_type VARCHAR(32), -- PLACE, MODIFY, CANCEL
  old_quantity INT,
  new_quantity INT,
  old_price DECIMAL,
  new_price DECIMAL,
  charges_delta DECIMAL,
  created_at TIMESTAMP DEFAULT now()
);

12.3 Modification Accounting Logic
public void modifyOrder(...) {
    OrderSnapshot before = snapshot(orderId);

    BrokerResponse ack = broker.modify(...);

    OrderSnapshot after = snapshot(orderId);

    recordEvent(before, after);
    recomputeChargesDelta(before, after);
}


Charges delta is additive and immutable.

12.4 Cancellation Charges
Scenario	Charge
Cancel before ACK	0
Cancel after ACK	Exchange txn + GST
Partial fill	Proportional charges
13. Trade → Settlement → P&L Linkage

This is mandatory for professional trading systems.

13.1 Trade Table
CREATE TABLE trades (
  trade_id VARCHAR(64),
  order_id VARCHAR(64),
  quantity INT,
  price DECIMAL,
  traded_at TIMESTAMP,
  exchange VARCHAR(16)
);

13.2 Settlement Table
CREATE TABLE settlements (
  settlement_id VARCHAR(64),
  trade_id VARCHAR(64),
  settlement_date DATE,
  net_amount DECIMAL,
  charges DECIMAL,
  status VARCHAR(16)
);

13.3 P&L Table
CREATE TABLE pnl (
  user_id VARCHAR(64),
  instrument_key VARCHAR(64),
  realized_pnl DECIMAL,
  unrealized_pnl DECIMAL,
  charges DECIMAL,
  as_of DATE
);

13.4 P&L Computation Formula
Net P&L =
(Sell Value – Buy Value)
– All Charges (broker + statutory)


Charges come ONLY from order_charges table.

14. Audit Export (CSV / PDF / Regulator Pack)
14.1 Export Scope

Regulators typically request:

Orders

Modifications

Charges

Trades

Settlements

P&L

Latency metrics

14.2 CSV Export (Deterministic)
List<OrderAuditRow> rows = auditService.fetchRange(from, to);
csvWriter.write(rows);


CSV headers are frozen and versioned.

14.3 PDF Export (Signed)

PDF includes:

Broker disclaimer

System timestamp

Hash checksum

Operator ID

pdf.addFooter("SHA256: " + checksum);

14.4 SEBI-Style Regulator Pack (ZIP)
/audit-pack-2025-01/
 ├── orders.csv
 ├── charges.csv
 ├── trades.csv
 ├── settlements.csv
 ├── pnl.csv
 ├── latency.csv
 ├── config_snapshot.json
 └── README.txt

14.5 README.txt (Excerpt)

This audit package contains immutable transactional records generated by the trading system. All data is derived directly from production persistence layers and has not been altered post-generation.

15. CLI / Frontend / REST Parity
CLI
vega audit export --from 2025-01-01 --to 2025-01-31

REST
GET /api/audit/export?from=2025-01-01&to=2025-01-31

React
await api.download("/audit/export", { from, to })

16. Compliance Guarantees Achieved

✔ Immutability of financial records
✔ Deterministic charges & P&L
✔ Full lifecycle traceability
✔ Independent reproducibility
✔ Regulator-ready exports

17. What This Enables Next (Optional)

If you want, the next logical extensions are:

Broker dispute reconciliation engine

Trade replay simulator

SEBI inspection mode (read-only lockdown)

Cross-broker charge normalization

Latency SLA breach alerts

This completes the full enterprise trading accounting and compliance stack.