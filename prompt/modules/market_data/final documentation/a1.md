1. Final Architecture Answer (Unambiguous)
✔ Do you need both documentations?

Yes. Mandatory.

Documentation	Role in MarketDataStreamV3	Required
Documentation 1 (Authorize V3)	Secure WebSocket endpoint discovery	Yes
Documentation 2 (Feed V3)	Subscription, streaming, protobuf decoding	Yes

Doc 1 gets you the door key.
Doc 2 tells you how to enter, speak, and receive data inside.

2. What You Have Today (Gap Analysis)
What your current script already does

✔ Token-based authorization
✔ Calls /v3/feed/market-data-feed/authorize
✔ Extracts authorized_redirect_uri

What is missing

❌ Persistent WebSocket lifecycle management
❌ Subscription protocol enforcement
❌ Protobuf schema versioning
❌ Backpressure handling
❌ Reconnect + resubscribe
❌ Connection & subscription limit enforcement
❌ Market status synchronization logic

All of these come only from Documentation 2.

3. How MarketDataStreamV3 Must Be Structured

Think in four mandatory layers:

MarketDataStreamV3
├── Authorization Layer      (Doc 1)
├── WebSocket Transport      (Doc 2)
├── Subscription Engine      (Doc 2)
├── Feed Decoder + Dispatcher (Doc 2)


Your current implementation stops at layer 1.

4. Step-by-Step Implementation Guide
STEP 1 — Keep Your Existing Authorization Code (Doc 1)

You already have this. Do not change it, only isolate it.

public interface MarketFeedAuthorizer {
    URI authorize(String accessToken);
}


Implementation = your existing getWebsocketUrl() logic.

STEP 2 — Implement WebSocket Transport (Doc 2)
Requirements from Documentation 2

Must connect to wss://...authorized_redirect_uri

Must support:

Binary frames

Ping/Pong (automatic)

Graceful reconnect

Recommended abstraction
public interface MarketWebSocketTransport {
    void connect(URI uri);
    void disconnect();
    void send(byte[] payload);
}


Use org.java_websocket.client.WebSocketClient internally.

STEP 3 — Implement Subscription Engine (Doc 2)
Subscription message format (mandatory)
{
  "guid": "uuid",
  "method": "sub",
  "data": {
    "mode": "full",
    "instrumentKeys": ["NSE_INDEX|Nifty Bank"]
  }
}

Enterprise rules you must enforce

Validate instrument count vs limits

Track active subscriptions

Support:

sub

unsub

change_mode

Example builder
public class SubscriptionRequestBuilder {

    public static byte[] subscribe(List<String> keys, Mode mode) {
        JsonObject request = new JsonObject();
        request.addProperty("guid", UUID.randomUUID().toString());
        request.addProperty("method", "sub");

        JsonObject data = new JsonObject();
        data.addProperty("mode", mode.name().toLowerCase());
        data.add("instrumentKeys", gson.toJsonTree(keys));

        request.add("data", data);
        return request.toString().getBytes(StandardCharsets.UTF_8);
    }
}

STEP 4 — Implement Protobuf Feed Decoder (Doc 2)
Mandatory

Decode binary frames

Use official .proto file

Handle malformed messages safely

public class FeedDecoder {

    public FeedResponse decode(ByteBuffer buffer) {
        try {
            return MarketDataFeedV3.FeedResponse.parseFrom(buffer.array());
        } catch (InvalidProtocolBufferException e) {
            throw new FeedDecodeException(e);
        }
    }
}

STEP 5 — Market Synchronization Logic (Doc 2)
From documentation:

First tick → market_info

Second tick → snapshot

Subsequent ticks → live updates

Required behavior

Do not process ticks until market_info arrives

Cache market segment status

Reject feeds from CLOSED segments

STEP 6 — Reconnect & Resubscribe Strategy (Doc 2)
Required

On disconnect:

Re-authorize (Doc 1)

Reconnect WS

Resubscribe ALL active instruments

Use exponential backoff

Rotate tokens if auth fails

STEP 7 — Backpressure & Dispatch (Enterprise Requirement)

Doc 2 implies:

High tick frequency

Binary throughput

You must add:

Bounded queues

Drop / coalesce policy

Async consumers

5. How to Integrate with MarketDataStreamV3
Final runtime flow
start()
 ├── authorize()            ← Doc 1
 ├── connectWebSocket()     ← Doc 2
 ├── waitForOpen()
 ├── subscribe()            ← Doc 2
 ├── decodeProtobuf()       ← Doc 2
 ├── dispatchTicks()
 └── monitorHealth()

6. What NOT To Do

❌ Do NOT rely on SDK
❌ Do NOT send text WS frames
❌ Do NOT ignore limits
❌ Do NOT skip market_info
❌ Do NOT hardcode reconnect URLs

7. Final Answer (Clear and Final)

Yes, you must implement Documentation 2 on top of Documentation 1.
Documentation 1 alone does NOT produce a working MarketDataStreamV3.

Your current script is a foundation, not a full system.

