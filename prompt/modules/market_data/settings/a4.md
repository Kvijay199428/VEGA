Java subscription validator for MarketDataStreamerV3 that enforces connections and per-category subscription limits for Normal and Upstox Plus users. This class can be used in both CLI and frontend backends.

1️⃣ Define Enums for Categories and User Types
public enum UserType {
    NORMAL,
    PLUS
}

public enum SubscriptionCategory {
    LTPC,
    OPTION_GREEKS,
    FULL,
    FULL_D30  // specific for Upstox Plus
}

2️⃣ Create a SubscriptionLimits Class
public class SubscriptionLimits {
    private final int individualLimit;
    private final int combinedLimit;

    public SubscriptionLimits(int individualLimit, int combinedLimit) {
        this.individualLimit = individualLimit;
        this.combinedLimit = combinedLimit;
    }

    public int getIndividualLimit() {
        return individualLimit;
    }

    public int getCombinedLimit() {
        return combinedLimit;
    }
}

3️⃣ Define Limits Map for Users
import java.util.EnumMap;
import java.util.Map;

public class LimitsConfig {

    public static final int NORMAL_CONNECTIONS = 2;
    public static final int PLUS_CONNECTIONS = 5;

    public static final Map<SubscriptionCategory, SubscriptionLimits> NORMAL_LIMITS = new EnumMap<>(SubscriptionCategory.class);
    public static final Map<SubscriptionCategory, SubscriptionLimits> PLUS_LIMITS = new EnumMap<>(SubscriptionCategory.class);

    static {
        // Normal Users
        NORMAL_LIMITS.put(SubscriptionCategory.LTPC, new SubscriptionLimits(5000, 2000));
        NORMAL_LIMITS.put(SubscriptionCategory.OPTION_GREEKS, new SubscriptionLimits(3000, 2000));
        NORMAL_LIMITS.put(SubscriptionCategory.FULL, new SubscriptionLimits(2000, 1500));

        // Upstox Plus
        PLUS_LIMITS.put(SubscriptionCategory.FULL_D30, new SubscriptionLimits(50, 1500));
    }

    public static Map<SubscriptionCategory, SubscriptionLimits> getLimits(UserType userType) {
        return userType == UserType.PLUS ? PLUS_LIMITS : NORMAL_LIMITS;
    }

    public static int getConnectionLimit(UserType userType) {
        return userType == UserType.PLUS ? PLUS_CONNECTIONS : NORMAL_CONNECTIONS;
    }
}

4️⃣ Subscription Validator
import java.util.Map;

public class SubscriptionValidator {

    private final UserType userType;
    private int activeConnections;
    private final Map<SubscriptionCategory, Integer> subscriptions; // category -> keys count

    public SubscriptionValidator(UserType userType) {
        this.userType = userType;
        this.activeConnections = 0;
        this.subscriptions = new java.util.EnumMap<>(SubscriptionCategory.class);
    }

    public void addConnection() {
        if (activeConnections >= LimitsConfig.getConnectionLimit(userType)) {
            throw new IllegalStateException("Maximum connections exceeded for user type: " + userType);
        }
        activeConnections++;
    }

    public void removeConnection() {
        if (activeConnections > 0) activeConnections--;
    }

    public void subscribe(SubscriptionCategory category, int keysCount) {
        Map<SubscriptionCategory, SubscriptionLimits> limits = LimitsConfig.getLimits(userType);

        if (!limits.containsKey(category)) {
            throw new IllegalArgumentException("Category not supported for user type: " + category);
        }

        int combinedLimit = limits.get(category).getCombinedLimit();
        int individualLimit = limits.get(category).getIndividualLimit();

        int activeCategories = subscriptions.size();
        int limitToApply = activeCategories > 0 ? combinedLimit : individualLimit;

        if (keysCount > limitToApply) {
            throw new IllegalArgumentException(
                    String.format("Subscription keys exceed limit for category %s. Limit: %d, Requested: %d",
                            category, limitToApply, keysCount));
        }

        subscriptions.put(category, keysCount);
    }

    public void unsubscribe(SubscriptionCategory category) {
        subscriptions.remove(category);
    }

    public int getActiveConnections() {
        return activeConnections;
    }

    public Map<SubscriptionCategory, Integer> getSubscriptions() {
        return subscriptions;
    }
}

5️⃣ Usage Example
public class MarketFeederClient {
    public static void main(String[] args) {
        SubscriptionValidator validator = new SubscriptionValidator(UserType.NORMAL);

        // Add connections
        validator.addConnection();
        validator.addConnection();
        // validator.addConnection(); // will throw exception

        // Subscribe to categories
        validator.subscribe(SubscriptionCategory.LTPC, 5000); // OK
        // validator.subscribe(SubscriptionCategory.OPTION_GREEKS, 2500); // throws exception (combined limit 2000)

        System.out.println("Active connections: " + validator.getActiveConnections());
        System.out.println("Subscriptions: " + validator.getSubscriptions());
    }
}

✅ Features of this Implementation

Enforces connection limits per user type.

Enforces subscription limits per category, including combined vs individual rules.

Works for CLI or backend supporting Vite+React frontend.

Easy to extend for new categories (e.g., Full D30 for Plus users).

Throws clear exceptions if limits are exceeded.