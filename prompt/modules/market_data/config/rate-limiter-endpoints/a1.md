complete enterprise-grade implementation guide for integrating MarketDataStreamerV3 and PortfolioStreamFeedV2 with rate limits, replay, event bus, Micrometer metrics, and CLI + Vite/React frontend. I’ve structured it as a step-by-step blueprint that can be directly followed.

Enterprise Implementation Guide: MarketDataStreamerV3 + PortfolioStreamFeedV2
1️⃣ Project Structure

Recommended Maven structure:

market-feeder-springboot/
├── pom.xml
├── src/main/java/com/vegatrader/marketfeeder
│   ├── MarketFeederApplication.java
│   ├── config/
│   │   ├── WebSocketConfig.java
│   │   ├── MicrometerConfig.java
│   │   ├── AppProperties.java
│   │   └── RateLimiterConfig.java
│   ├── feeder/
│   │   ├── MarketDataStreamerV3.java
│   │   ├── SubscriptionManager.java
│   │   ├── FeedDispatcher.java
│   │   ├── MarketDataEvent.java
│   │   ├── TickEvent.java
│   │   ├── ReplayService.java
│   │   └── ApiRateLimiterService.java
│   └── portfolio/
│       └── PortfolioStreamFeedV2Adapter.java
└── src/main/resources/
    ├── application.yml
    ├── logback-spring.xml

2️⃣ Dependencies (pom.xml)
<dependencies>
    <!-- Spring Boot -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>
    
    <!-- SLF4J + Logback -->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.4.14</version>
    </dependency>

    <!-- Micrometer + Prometheus -->
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-registry-prometheus</artifactId>
    </dependency>

    <!-- Protobuf -->
    <dependency>
        <groupId>com.google.protobuf</groupId>
        <artifactId>protobuf-java</artifactId>
        <version>3.21.12</version>
    </dependency>

    <!-- Optional: Guava for RateLimiter -->
    <dependency>
        <groupId>com.google.guava</groupId>
        <artifactId>guava</artifactId>
        <version>32.1.2-jre</version>
    </dependency>
</dependencies>

3️⃣ Logging (Logback)

src/main/resources/logback-spring.xml:

<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="STDOUT" />
    </root>
</configuration>

4️⃣ Configuration

application.yml

server:
  port: 8080

market:
  websocket-url: wss://wsfeeder-api.upstox.com/market-data-feeder/v3
  reconnect-delay: 5000
  max-instrument-keys:
    ltpc: 5000
    option-greeks: 3000
    full: 2000
  plus-limits:
    full-d30: 50

5️⃣ Rate Limiter (Enterprise-Ready)

ApiRateLimiterService.java:

@Service
public class ApiRateLimiterService {
    private final RateLimiter standardApiLimiter = RateLimiter.create(50.0); // 50 req/s
    private final RateLimiter multiOrderLimiter = RateLimiter.create(4.0);  // 4 req/s

    public boolean acquireStandard() {
        return standardApiLimiter.tryAcquire();
    }

    public boolean acquireMultiOrder() {
        return multiOrderLimiter.tryAcquire();
    }

    // Optional: integrate Micrometer metrics
    @Autowired
    private MeterRegistry meterRegistry;

    @PostConstruct
    public void initMetrics() {
        meterRegistry.gauge("api_rate_limiter.standard.available_permits", standardApiLimiter, RateLimiter::getRate);
        meterRegistry.gauge("api_rate_limiter.multi_order.available_permits", multiOrderLimiter, RateLimiter::getRate);
    }
}


Integration: All API calls in MarketDataStreamerV3 and PortfolioStreamFeedV2Adapter should first call acquireStandard() or acquireMultiOrder().

6️⃣ Subscription Limit Enforcement

SubscriptionManager.java:

public class SubscriptionManager {
    private final Map<String, Integer> currentSubscriptions = new ConcurrentHashMap<>();

    public boolean canSubscribe(String category, int requestedKeys, boolean isPlusUser) {
        int limit = isPlusUser ? AppProperties.plusLimits.get(category) : AppProperties.maxInstrumentKeys.get(category);
        return requestedKeys + currentSubscriptions.getOrDefault(category, 0) <= limit;
    }

    public void subscribe(String category, List<String> keys) {
        currentSubscriptions.put(category,
                currentSubscriptions.getOrDefault(category, 0) + keys.size());
    }
}

7️⃣ Replay & Persistence

ReplayService.java:

@Service
public class ReplayService {
    private final FeedDispatcher dispatcher;

    @Autowired
    public ReplayService(FeedDispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }

    public void replay(List<TickEvent> historicalTicks) {
        for (TickEvent tick : historicalTicks) {
            dispatcher.dispatch(tick);
        }
    }
}


Store TickEvent in database (PostgreSQL, TimescaleDB, or Redis) for deterministic backtesting.

Provide replay CLI command: java -jar market-feeder.jar --replay date=YYYY-MM-DD

8️⃣ Event Bus Alignment

FeedDispatcher dispatches MarketDataEvent and PortfolioUpdateEvent.

Both MarketDataStreamerV3 and PortfolioStreamFeedV2 post events to InMemoryEventBus.

Ensures decoupled subscribers for analytics, dashboard, or backend triggers.

9️⃣ Micrometer + Prometheus

MicrometerConfig.java:

@Configuration
public class MicrometerConfig {
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config().commonTags("application", "market-feeder");
    }
}


Prometheus metrics exposed at /actuator/prometheus.

Track:

Active subscriptions

Tick events per second

API rate limiter status

10️⃣ CLI + Vite/React Integration

CLI: Use Spring Boot properties + commands:

java -jar market-feeder.jar --subscribe NiftyBank,Nifty50 --replay date=2025-12-28


Vite/React Frontend:

Call Spring Boot REST endpoints:

/api/market/subscribe

/api/market/replay

/api/portfolio/status

Display remaining API calls using rate limiter metrics.

Subscribe/unsubscribe instrument keys from UI with limit enforcement.

11️⃣ Testing & Quality

JUnit + WireMock for API endpoint testing and replay service.

Integration tests: Ensure WebSocket reconnection, tick dispatch, replay, and API rate limits.

Prometheus + Grafana dashboard: Monitor tick rates, subscriptions, and API rate limiter health.

12️⃣ Recommended Enhancements

Enterprise Metrics Dashboard – Active subscriptions, feed latency, reconnections.

CLI & UI unified rate-limiter info – Show “Standard API / Multi-Order API remaining calls”.

Replay store & query – Enable deterministic simulations for any date/time.

WebSocket reconnection backoff – Exponential backoff with jitter.

Subscription limit alerting – Send warnings if close to limits.

This guide aligns MarketDataStreamerV3, PortfolioStreamFeedV2, replay, backpressure, rate limiting, metrics, and CLI + React frontend into a production-ready enterprise-grade solution.

I can also create a visual workflow diagram showing:

[Frontend/CLI] → [Spring Boot API] → [RateLimiter] → [MarketDataStreamerV3/PortfolioStreamFeedV2] → [EventBus] → [ReplayService / Analytics / UI]


This will help developers and ops teams understand data flow and throttling boundaries.