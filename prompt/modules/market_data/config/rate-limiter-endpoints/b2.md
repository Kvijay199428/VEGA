full enterprise-grade scaffold for the Rate Limiter module, fully compatible with MarketDataStreamerV3 and PortfolioDataStreamerV2, with Spring Boot, CLI, and Prometheus/Micrometer integration.

1️⃣ Project Structure
market-feeder-springboot/
├── src/main/java/com/vegatrader/marketfeeder/ratelimiter
│   ├── EnterpriseRateLimiterService.java
│   ├── RateLimiter.java
│   ├── TokenBucketRateLimiter.java
│   ├── TokenBucket.java
│   ├── RateLimitExceededException.java
│   └── RateLimiterController.java
├── src/main/resources/
│   ├── application.yml
│   └── logback-spring.xml
└── pom.xml

2️⃣ Core Classes
RateLimiter.java
package com.vegatrader.marketfeeder.ratelimiter;

import java.util.Map;

public interface RateLimiter {
    boolean tryAcquire(String category, int keysRequested);
    void release(String category, int keysUsed);
    Map<String, Integer> getCurrentUsage();
}

TokenBucket.java
package com.vegatrader.marketfeeder.ratelimiter;

import java.util.concurrent.atomic.AtomicInteger;

public class TokenBucket {
    private final int capacity;
    private final AtomicInteger tokens;

    public TokenBucket(int capacity) {
        this.capacity = capacity;
        this.tokens = new AtomicInteger(capacity);
    }

    public boolean consume(int n) {
        while (true) {
            int current = tokens.get();
            if (current < n) return false;
            if (tokens.compareAndSet(current, current - n)) return true;
        }
    }

    public void returnTokens(int n) {
        tokens.updateAndGet(current -> Math.min(current + n, capacity));
    }

    public int getAvailableTokens() {
        return tokens.get();
    }

    public int getUsedTokens() {
        return capacity - tokens.get();
    }
}

TokenBucketRateLimiter.java
package com.vegatrader.marketfeeder.ratelimiter;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class TokenBucketRateLimiter implements RateLimiter {

    private final Map<String, TokenBucket> categoryBuckets = new ConcurrentHashMap<>();
    private final int combinedLimit;

    public TokenBucketRateLimiter(Map<String, Integer> categoryLimits, int combinedLimit) {
        categoryLimits.forEach((k, v) -> categoryBuckets.put(k, new TokenBucket(v)));
        this.combinedLimit = combinedLimit;
    }

    @Override
    public boolean tryAcquire(String category, int keysRequested) {
        TokenBucket bucket = categoryBuckets.get(category);
        if (bucket == null) return false;

        int totalUsed = getCombinedUsage();
        if (bucket.getAvailableTokens() < keysRequested || totalUsed + keysRequested > combinedLimit) {
            return false;
        }
        return bucket.consume(keysRequested);
    }

    @Override
    public void release(String category, int keysUsed) {
        TokenBucket bucket = categoryBuckets.get(category);
        if (bucket != null) bucket.returnTokens(keysUsed);
    }

    @Override
    public Map<String, Integer> getCurrentUsage() {
        Map<String, Integer> usage = new ConcurrentHashMap<>();
        categoryBuckets.forEach((k, v) -> usage.put(k, v.getUsedTokens()));
        return usage;
    }

    private int getCombinedUsage() {
        return categoryBuckets.values().stream().mapToInt(TokenBucket::getUsedTokens).sum();
    }
}

EnterpriseRateLimiterService.java
package com.vegatrader.marketfeeder.ratelimiter;

import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class EnterpriseRateLimiterService {

    private final Map<String, RateLimiter> userLimiters = new ConcurrentHashMap<>();

    public boolean trySubscribe(String userId, String category, int keysRequested) {
        RateLimiter limiter = userLimiters.computeIfAbsent(userId, u -> 
            new TokenBucketRateLimiter(Map.of(
                "LTPC", 5000,
                "OptionGreeks", 3000,
                "Full", 2000
            ), 2000)
        );
        return limiter.tryAcquire(category, keysRequested);
    }

    public void release(String userId, String category, int keysUsed) {
        RateLimiter limiter = userLimiters.get(userId);
        if (limiter != null) limiter.release(category, keysUsed);
    }

    public Map<String, Integer> currentUsage(String userId) {
        RateLimiter limiter = userLimiters.get(userId);
        return limiter != null ? limiter.getCurrentUsage() : Map.of();
    }
}

RateLimiterController.java (REST + Frontend access)
package com.vegatrader.marketfeeder.ratelimiter;

import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/ratelimiter")
public class RateLimiterController {

    private final EnterpriseRateLimiterService limiterService;

    public RateLimiterController(EnterpriseRateLimiterService limiterService) {
        this.limiterService = limiterService;
    }

    @GetMapping("/{userId}/usage")
    public Map<String, Integer> getCurrentUsage(@PathVariable String userId) {
        return limiterService.currentUsage(userId);
    }

    @PostMapping("/{userId}/release")
    public void release(@PathVariable String userId,
                        @RequestParam String category,
                        @RequestParam int keys) {
        limiterService.release(userId, category, keys);
    }
}

3️⃣ Spring Boot Configuration
application.yml
server:
  port: 8080

management:
  endpoints:
    web:
      exposure:
        include: prometheus, health

Prometheus Metrics

Add Micrometer dependency:

<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>


Instrument the service:

@Autowired
private MeterRegistry meterRegistry;

public boolean trySubscribe(...) {
    boolean allowed = limiter.tryAcquire(...);
    meterRegistry.gauge("rate_limiter.active_keys", limiter.getCurrentUsage().values().stream().mapToInt(Integer::intValue).sum());
    return allowed;
}

4️⃣ Integration with Market & Portfolio Streamers
// Before subscription
if (!enterpriseRateLimiterService.trySubscribe(userId, category, keys)) {
    throw new RateLimitExceededException("Exceeded subscription limit");
}

// After unsubscribe / replay
enterpriseRateLimiterService.release(userId, category, keys);


This works seamlessly for both MarketDataStreamerV3 and PortfolioStreamFeedV2Adapter.