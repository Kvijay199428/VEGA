exactly the same rule as MarketDataStreamV3 applies.

Documentation	Role	Required
Doc 1 – Authorize API	Secure, one-time WSS endpoint acquisition	Mandatory
Doc 2 – WebSocket Feed	Actual streaming protocol & payloads	Mandatory

Why this split exists

Doc 1 is HTTP control-plane

Doc 2 is WebSocket data-plane

MarketDataStreamV3 already follows this exact pattern
→ PortfolioStreamFeedV2 must follow it as well.

2. High-level architecture (Aligned with MarketDataStreamV3)
portfolio-stream/
├── portfolio-auth/
│   └── PortfolioAuthorizeClient
├── portfolio-ws/
│   ├── PortfolioWebSocketClient
│   ├── PortfolioReconnectManager
│   └── PortfolioHeartbeatMonitor
├── portfolio-events/
│   ├── PortfolioEvent
│   ├── OrderUpdateEvent
│   ├── PositionUpdateEvent
│   ├── HoldingUpdateEvent
│   └── GttOrderUpdateEvent
├── portfolio-buffer/
│   └── PortfolioEventBuffer (bounded, backpressure)
├── portfolio-persistence/
│   └── PortfolioEventRepository
├── portfolio-metrics/
│   └── PortfolioMetrics
└── portfolio-starter/
    └── PortfolioStreamFeedAutoConfiguration


This mirrors MarketDataStreamV3 exactly:

Control plane

Streaming plane

Event normalization

Event bus publishing

Persistence

Metrics

Spring Boot starter

3. Maven multi-module layout (required)
vega-upstox-streams/
├── pom.xml (parent)
├── common-event-bus/
├── marketdata-stream-v3/
├── portfolio-stream-v2/
│   ├── portfolio-auth
│   ├── portfolio-ws
│   ├── portfolio-events
│   ├── portfolio-buffer
│   ├── portfolio-persistence
│   ├── portfolio-metrics
│   └── portfolio-starter


Rule

PortfolioStreamFeedV2 must reuse the same EventBus interfaces used by MarketDataStreamV3.

No duplicate buses. No parallel pipelines.

4. Portfolio Authorize Client (Doc 1)
Responsibility

Fetch single-use authorized_redirect_uri

Apply update_types

Handle retry + token expiry

Interface
public interface PortfolioAuthorizeClient {
    URI authorize(Set<PortfolioUpdateType> updateTypes);
}

Key rules

Use snake_case only

Cache nothing

URI is single-use

Treat 401 as token invalid → signal TokenLeaseManager

5. Portfolio WebSocket Client (Doc 2)
Core differences vs MarketDataStreamV3
Aspect	MarketData	Portfolio
Subscription message	Required	Not required
Payload format	Protobuf	JSON
Instrument keys	Mandatory	Not applicable
Feed start	After SUB	Immediately on connect
WebSocket behavior

Auto-redirect must be enabled

Authorization header must be passed

Messages start streaming immediately

6. Event normalization (CRITICAL)

All incoming messages must be normalized into typed domain events.

Base contract
public interface PortfolioEvent {
    PortfolioUpdateType type();
    Instant receivedAt();
    String userId();
}

Concrete events

OrderUpdateEvent

PositionUpdateEvent

HoldingUpdateEvent

GttOrderUpdateEvent

Snake_case → Java fields
CamelCase fields are deprecated — ignore them.

7. Backpressure & buffering (Same as MarketDataStreamV3)
Why it matters

Portfolio updates can spike during:

Bulk order placement

RMS rejections

End-of-day square-off

Implementation
PortfolioEventBuffer
- Bounded queue
- Drop or park strategy (configurable)
- Consumer lag metrics


DO NOT

Process directly in WebSocket thread

Persist inline

8. Event bus alignment (Shared with MarketDataStreamV3)

Mandatory reuse

EventBus.publish(PortfolioEvent)


Benefits:

Unified observability

Shared persistence logic

Same replay & audit tooling

9. Database persistence
Recommended schema
portfolio_events (
  id BIGSERIAL PRIMARY KEY,
  update_type VARCHAR(20),
  payload JSONB,
  received_at TIMESTAMP,
  user_id VARCHAR(32)
)

Rules

Persist raw JSON

Deserialize downstream

Keep immutable audit log

10. Micrometer metrics (Required)

Expose the following:

Metric	Type
portfolio.ws.connected	gauge
portfolio.ws.reconnect.count	counter
portfolio.events.in	counter
portfolio.events.dropped	counter
portfolio.buffer.depth	gauge
portfolio.persist.latency	timer

These must integrate with the same MeterRegistry used by MarketDataStreamV3.

11. Reconnect strategy (Production-grade)
Trigger	Action
Socket close	Re-authorize → reconnect
401 during authorize	Rotate token
Heartbeat timeout	Force reconnect
Malformed payload	Drop + metric

Exponential backoff

1s → 2s → 5s → 10s → 30s (cap)

12. Spring Boot starter
Auto-config
@ConditionalOnProperty("upstox.portfolio.enabled=true")
public class PortfolioStreamFeedAutoConfiguration

Properties
upstox:
  portfolio:
    enabled: true
    update-types: order,position,holding
    buffer:
      size: 10_000
    reconnect:
      max-delay: 30s

13. Testing strategy (Mandatory)
Unit

JSON → Event mapping

Buffer overflow handling

Snake_case enforcement

Integration (Mock WebSocket)

Simulate redirect

Send burst updates

Validate reconnect logic

Contract

Validate update_type enum mapping

Reject unknown fields

14. Final verdict (Direct answer)

Yes, you must implement Documentation 2 logic even if Documentation 1 works.

Documentation 1:

Gets you connected

Documentation 2:

Defines how the system behaves under load

Without Doc 2 handling:

No reconnection safety

No event normalization

No enterprise guarantees