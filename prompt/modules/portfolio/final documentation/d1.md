PortfolioStreamFeedV2 also requires BOTH documentations, exactly like MarketDataStreamV3.

Documentation	Role	Mandatory
Documentation 1	WebSocket authorization + endpoint discovery	YES
Documentation 2	Live portfolio streaming protocol	YES

However, PortfolioStreamFeedV2 is architecturally simpler than MarketDataStreamV3 because:

No subscription messages

No protobuf

No binary decoding

Server pushes updates automatically

High-Level Architecture (PortfolioStreamFeedV2)
PortfolioStreamFeedV2
├── auth
│   └── PortfolioFeedAuthorizer        (Doc 1)
├── websocket
│   ├── PortfolioWebSocketClient       (Doc 2)
│   ├── ReconnectManager
│   └── HeartbeatMonitor
├── filter
│   └── UpdateTypeFilter               (order / position / holding)
├── buffer
│   ├── PortfolioEventBuffer
│   └── BackpressurePolicy
├── dispatcher
│   └── PortfolioEventDispatcher
├── model
│   ├── OrderUpdate
│   ├── PositionUpdate
│   └── HoldingUpdate
├── config
│   └── PortfolioStreamProperties
└── starter
    └── PortfolioStreamAutoConfiguration


This aligns with enterprise streaming design, not SDK shortcuts.

1. Documentation Mapping (Important)
Documentation 1 → Authorization Layer

Purpose

Secure, one-time WebSocket URL

Optional filtering using update_types

Your responsibility

Call REST endpoint

Parse authorized_redirect_uri

Re-authorize on reconnect

Documentation 2 → Streaming Layer

Purpose

Receive JSON messages

No request payload required

Server pushes updates automatically

Your responsibility

Connect to wss://

Handle JSON messages

Route by update_type

Apply backpressure

Reconnect on disconnect

2. Authorization Layer (Doc 1)
Interface
public interface PortfolioFeedAuthorizer {
    URI authorize(String accessToken, Set<UpdateType> updateTypes);
}

Implementation
public class UpstoxPortfolioFeedAuthorizer
        implements PortfolioFeedAuthorizer {

    private static final String AUTH_URL =
        "https://api.upstox.com/v2/feed/portfolio-stream-feed/authorize";

    private final HttpClient httpClient = HttpClient.newHttpClient();
    private final Gson gson = new Gson();

    @Override
    public URI authorize(String token, Set<UpdateType> updateTypes) {

        String query = updateTypes.isEmpty()
            ? ""
            : "?update_types=" + updateTypes.stream()
                .map(UpdateType::value)
                .collect(Collectors.joining(","));

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(AUTH_URL + query))
            .header("Authorization", "Bearer " + token)
            .header("Accept", "application/json")
            .build();

        try {
            HttpResponse<String> response =
                httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            JsonObject root = gson.fromJson(response.body(), JsonObject.class);
            String wss = root.getAsJsonObject("data")
                .get("authorized_redirect_uri")
                .getAsString();

            return URI.create(wss);

        } catch (Exception e) {
            throw new PortfolioAuthorizationException(e);
        }
    }
}


✔ Uses snake_case field (non-deprecated)
✔ Matches Documentation 1 exactly

3. WebSocket Client Layer (Doc 2)
Interface
public interface PortfolioWebSocketClient {
    void connect(URI uri);
    void close();
}

Implementation
public class UpstoxPortfolioWebSocketClient
        extends WebSocketClient
        implements PortfolioWebSocketClient {

    private final Consumer<String> messageHandler;

    public UpstoxPortfolioWebSocketClient(
            URI uri,
            Consumer<String> messageHandler) {
        super(uri);
        this.messageHandler = messageHandler;
    }

    @Override
    public void onOpen(ServerHandshake handshake) {}

    @Override
    public void onMessage(String message) {
        messageHandler.accept(message);
    }

    @Override
    public void onClose(int code, String reason, boolean remote) {}

    @Override
    public void onError(Exception ex) {}
}


✔ No subscription message required
✔ JSON frames only
✔ Heartbeat handled automatically

4. Update Type Routing (Core Logic)

Documentation 2 mandates:

{
  "update_type": "order"
}

Enum
public enum UpdateType {
    ORDER("order"),
    GTT_ORDER("gtt_order"),
    POSITION("position"),
    HOLDING("holding");

    private final String value;
    public String value() { return value; }
}

Router
public class PortfolioUpdateRouter {

    private final Gson gson = new Gson();

    public void route(String json) {
        JsonObject obj = gson.fromJson(json, JsonObject.class);
        String type = obj.get("update_type").getAsString();

        switch (type) {
            case "order" -> handleOrder(obj);
            case "position" -> handlePosition(obj);
            case "holding" -> handleHolding(obj);
            case "gtt_order" -> handleGtt(obj);
        }
    }
}

5. Backpressure & Buffering (Mandatory)

Portfolio updates can spike during:

Bulk order placement

RMS actions

Market open/close

Buffer
public class PortfolioEventBuffer {

    private final BlockingQueue<JsonObject> queue =
        new ArrayBlockingQueue<>(10_000);

    public void publish(JsonObject event) {
        if (!queue.offer(event)) {
            // Drop or compress
        }
    }

    public JsonObject consume() throws InterruptedException {
        return queue.take();
    }
}

6. Reconnect Strategy (Critical)

Reconnect flow:

disconnect
 → re-authorize (Doc 1)
 → new WSS URL
 → reconnect

Manager
public class PortfolioReconnectManager {

    private final ScheduledExecutorService scheduler =
        Executors.newSingleThreadScheduledExecutor();

    public void scheduleReconnect(Runnable task) {
        scheduler.scheduleWithFixedDelay(
            task, 3, 15, TimeUnit.SECONDS);
    }
}

7. Spring Boot Starter Layout
Module Structure
portfolio-stream-feed-v2-starter
├── autoconfigure
│   └── PortfolioStreamAutoConfiguration
├── auth
├── websocket
├── router
├── buffer
└── model

Auto-Configuration
@Configuration
@ConditionalOnProperty(
    name = "portfolio.stream.enabled",
    havingValue = "true"
)
public class PortfolioStreamAutoConfiguration {

    @Bean
    public PortfolioFeedAuthorizer authorizer() {
        return new UpstoxPortfolioFeedAuthorizer();
    }

    @Bean
    public PortfolioUpdateRouter router() {
        return new PortfolioUpdateRouter();
    }
}

application.yml
portfolio:
  stream:
    enabled: true
    update-types:
      - order
      - position
      - holding
    buffer:
      size: 10000

8. Testing Strategy (JUnit + Mock WS)
What to Test

Authorization response parsing

Routing by update_type

Reconnect behavior

Buffer overflow handling

Mock Tools

MockWebServer (OkHttp)

Embedded WebSocketServer

9. Comparison with MarketDataStreamV3 (For Clarity)
Feature	MarketDataStreamV3	PortfolioStreamFeedV2
Authorization	REST	REST
WebSocket	Yes	Yes
Subscription	Required	❌ Not required
Binary frames	Yes	❌ JSON only
Protobuf	Yes	❌
Limits	Instrument-based	Update-type based
Market sync	Required	❌
Final Verdict (Unambiguous)

✔ You must implement both documentations
✔ PortfolioStreamFeedV2 is simpler but equally critical
✔ This guide gives you a drop-in enterprise blueprint
✔ Avoid SDK — HTTP + WS gives full control