Below is a production-grade, Selenium-safe design that exactly matches your requirements:

Login lifecycle is defined by PRIMARY access token validity using the "validity_at" from database "vega_trade.db" table "upstox_tokens".

Total required tokens = 6

Each token generation updates the Login Page

Final confirmation = all 6 tokens stored + authenticated API = 200

Only then redirect to Dashboard

This is written assuming a Java + Selenium + Backend-validated architecture (aligned with Vega / broker auth flows).

PART 1 — Selenium-Safe Login Success Detection (6-Token Model)
Core Rule (Authoritative)

Login is NOT successful until ALL 6 PRIMARY access tokens are generated, persisted, and validated via API.

UI state, URL, or DOM alone are never sufficient.

A. Data Model (Backend – Mandatory)
upstox_tokens table (simplified)
CREATE TABLE upstox_tokens (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(64),
    token_index INT,              -- 1 to 6
    access_token TEXT,
    validity_at TIMESTAMP,
    is_valid BOOLEAN,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

"validity_at" is the time when the token will expire have this structure "2025-12-31 03:30:00".

here is the complete sql query "INSERT INTO "main"."upstox_tokens" ("id", "access_token", "api_name", "client_id", "client_secret", "created_at", "expires_in", "is_primary", "last_refreshed", "redirect_uri", "refresh_token", "token_type", "api_index", "generated_at", "is_active", "purpose", "updated_at", "user_id", "validity_at") VALUES (1, 'eyJ0eXAiOiJKV1QiLCJrZXlfaWQiOiJza192MS4wIiwiYWxnIjoiSFMyNTYifQ.eyJzdWIiOiI3RUFIQkoiLCJqdGkiOiI2OTU0M2Y0MjZmYjIwNzM1ZTVhNzQ4MjUiLCJpc011bHRpQ2xpZW50IjpmYWxzZSwiaXNQbHVzUGxhbiI6dHJ1ZSwiaWF0IjoxNzY3MTI4ODk4LCJpc3MiOiJ1ZGFwaS1nYXRld2F5LXNlcnZpY2UiLCJleHAiOjE3NjcxMzIwMDB9.amT_x7Pqq2LzL0_554FMPmbMOLX1eVClTyNiEv808z8', 'PRIMARY', '4871f658-a594-47b8-8176-d0d77578ef02', 'ux7a2v5s58', 1767128898684, 86400, 0, NULL, 'http://localhost:28020/api/v1/auth/upstox/callback', NULL, NULL, 0, '2025-12-31T02:38:18.684925800', 1, NULL, 1767128898687, 0, '2025-12-31 03:30:00');"
"

B. Selenium-Safe Token Capture (Per Token)
1. Enable DevTools Network Capture
DevTools devTools = ((ChromeDriver) driver).getDevTools();
devTools.createSession();

devTools.send(Network.enable(
    Optional.empty(),
    Optional.empty(),
    Optional.empty()
));

2. Capture PRIMARY Access Token (OAuth Response)
AtomicReference<String> tokenRef = new AtomicReference<>();

devTools.addListener(Network.responseReceived(), response -> {
    String url = response.getResponse().getUrl();

    if (url.contains("/oauth/token") || url.contains("/authorize")) {
        Network.GetResponseBodyResponse body =
            devTools.send(Network.getResponseBody(response.getRequestId()));

        if (body.getBody().contains("access_token")) {
            String token = extractAccessToken(body.getBody());
            tokenRef.set(token);
        }
    }
});

3. Fallback: Browser Storage
JavascriptExecutor js = (JavascriptExecutor) driver;

String token = (String) js.executeScript(
    "return window.localStorage.getItem('access_token');"
);

C. Token Validation (Backend-Authoritative)
1. Expiry Validation
DecodedJWT jwt = JWT.decode(token);
boolean notExpired =
    jwt.getExpiresAt().toInstant().isAfter(Instant.now());

2. Mandatory Authenticated API Call
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.broker.com/v2/profile"))
    .header("Authorization", "Bearer " + token)
    .GET()
    .build();

HttpResponse<String> response =
    HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());

boolean apiOk = response.statusCode() == 200;

3. Persist Token
if (notExpired && apiOk) {
    tokenRepository.save(
        userId,
        tokenIndex,
        token,
        jwt.getExpiresAt(),
        true
    );
}

D. Token Generation Counter (Login Page Update)
Backend Endpoint
GET /auth/token-count

Response
{
  "generated": 4,
  "required": 6
}

Frontend Login Page Update Logic
fetch('/auth/token-count')
  .then(r => r.json())
  .then(data => {
     document.getElementById("tokenStatus").innerText =
       `Access Tokens Generated: ${data.generated} / ${data.required}`;
  });


Example UI text:

Access Tokens Generated: 4 / 6

E. Final Login Success Condition (NON-NEGOTIABLE)
boolean loginConfirmed =
    tokenRepository.countValidTokens(userId) == 6
    && authenticatedApiCallReturns200();


Only this condition authorizes dashboard redirect.

PART 2 — Login Lifecycle State Machine (PRIMARY Token Driven)

This state machine is fully deterministic, restart-safe, and scheduler-friendly.

State Diagram (Textual)
┌────────────────────┐
│ NOT_LOGGED_IN      │
└────────┬───────────┘
         │
         ▼
┌────────────────────┐
│ LOGIN_STARTED      │
│ (Browser Active)   │
└────────┬───────────┘
         │
         ▼
┌────────────────────┐
│ AUTH_FLOW_RUNNING  │
│ (OTP / CAPTCHA)   │
└────────┬───────────┘
         │
         ▼
┌────────────────────────────┐
│ TOKEN_PARTIAL (1–5 of 6)   │
│ Counter updating           │
└────────┬───────────────────┘
         │
         ▼
┌────────────────────────────┐
│ TOKEN_COMPLETE (6 of 6)    │
│ All tokens persisted       │
└────────┬───────────────────┘
         │
         ▼
┌────────────────────────────┐
│ PRIMARY_TOKEN_VALIDATED    │
│ API = 200                  │
└────────┬───────────────────┘
         │
         ▼
┌────────────────────────────┐
│ AUTHENTICATED              │
│ Login Confirmed            │
└────────┬───────────────────┘
         │
         ▼
┌────────────────────────────┐
│ DASHBOARD_REDIRECTED       │
└────────────────────────────┘

State Transition Rules (Formal Table)
From State	Condition	To State
NOT_LOGGED_IN	Login triggered	LOGIN_STARTED
LOGIN_STARTED	Browser ready	AUTH_FLOW_RUNNING
AUTH_FLOW_RUNNING	Token generated	TOKEN_PARTIAL
TOKEN_PARTIAL	count < 6	TOKEN_PARTIAL
TOKEN_PARTIAL	count == 6	TOKEN_COMPLETE
TOKEN_COMPLETE	API 200	PRIMARY_TOKEN_VALIDATED
PRIMARY_TOKEN_VALIDATED	confirmed	AUTHENTICATED
AUTHENTICATED	UI redirect	DASHBOARD_REDIRECTED
Token Expiry & Re-Entry
AUTHENTICATED
   ├── Any token expired → TOKEN_INVALIDATED
   ├── API 401 → RELOGIN_REQUIRED
   └── < 6 valid tokens → TOKEN_PARTIAL

Backend Guard (Single Source of Truth)
boolean isLoginFullyAuthenticated(String userId) {
    return tokenRepository.countValidTokens(userId) == 6
        && authApi.profile().statusCode() == 200;
}

Frontend Redirect Rule
if (response.authenticated === true) {
    window.location.href = "/dashboard";
}


Frontend never computes authentication itself.

Final Verdict (Strict)

Selenium detects token generation, not UI success

Backend validates token count + API health

Login page reflects real-time token progress

Dashboard access allowed only after 6/6 tokens

PRIMARY access token validity defines lifecycle