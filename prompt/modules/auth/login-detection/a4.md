However, the critical architectural distinction—which is where most implementations go wrong—is this:

username / PIN / TOTP authenticate the USER
client_id / client_secret authenticate the APPLICATION

Because you are authenticating 6 separate Upstox applications, the solution is not to put a single client_id and client_secret in application.properties.

Below is the correct, compliant, restart-safe, and Upstox-aligned solution.

1. Why your current idea (single client-id in properties) is WRONG

If you do this:

upstox.auth.auto.client-id=${UPSTOX_CLIENT_ID}
upstox.auth.auto.client-secret=${UPSTOX_CLIENT_SECRET}


Then:

You can generate only ONE access token

You cannot generate tokens for API 1–5

You break your 6-token lifecycle

You will be forced to re-login repeatedly

You cannot parallelize websockets / option chains

This directly conflicts with your stated requirement.

2. Correct Interpretation of Upstox OAuth (Based on Docs)

From the documentation you pasted (key points):

Authorize API
client_id = API Key (APP specific)
redirect_uri = APP specific
response_type = code

Get Token API
code = generated per client_id
client_id = APP specific
client_secret = APP specific

IMPORTANT CONSEQUENCE

Each client_id requires its own authorization code and access token

You cannot reuse:

authorization code

access token

client_secret

across apps.

3. Correct Configuration Strategy (Authoritative)
A. application.properties (ONLY COMMON USER CREDENTIALS)

This is correct and REQUIRED:

upstox.auth.auto.username=${UPSTOX_MOBILE_NUMBER}
upstox.auth.auto.password=${UPSTOX_PIN}
upstox.auth.auto.totp-secret=${UPSTOX_TOTP}

REMOVE these (do not exist as singletons):
❌ upstox.auth.auto.client-id
❌ upstox.auth.auto.client-secret

B. .env (APP-SPECIFIC CREDENTIALS — CORRECT)

You already have the perfect structure:

UPSTOX_CLIENT_ID_0
UPSTOX_CLIENT_SECRET_0
UPSTOX_CLIENT_ID_1
UPSTOX_CLIENT_SECRET_1
...
UPSTOX_CLIENT_ID_5
UPSTOX_CLIENT_SECRET_5


This is exactly what Upstox OAuth expects.

4. How Authentication MUST Work (End-to-End)
Step 1 — Discover All Apps Dynamically
List<UpstoxApp> apps = new ArrayList<>();

for (int i = 0; i < 10; i++) {
    String id = System.getenv("UPSTOX_CLIENT_ID_" + i);
    String secret = System.getenv("UPSTOX_CLIENT_SECRET_" + i);

    if (id != null && secret != null) {
        apps.add(new UpstoxApp(i, id, secret));
    }
}


This gives you N apps, not hard-coded 6.

Step 2 — For EACH App (client_id)
2.1 Authorize (Selenium / Browser)
GET /login/authorization/dialog
?client_id={client_id}
&redirect_uri={redirect_uri}
&response_type=code
&state=random


User authentication uses:

mobile

PIN

TOTP

⚠️ This step is per app, not once globally.

2.2 Capture Authorization Code
http://localhost:28020/api/v1/auth/upstox/callback?code=XYZ


Persist:

client_id

authorization_code

state

timestamp

2.3 Exchange Code → Access Token
POST /login/authorization/token
code
client_id
client_secret
redirect_uri
grant_type=authorization_code


Persist:

access_token

expires_at (3:30 AM rule)

client_id index

Step 3 — Validate Token (MANDATORY)
GET /v2/profile
Authorization: Bearer <access_token>


200 OK = VALID

5. Token Validity Model (Upstox-Specific)

From Upstox docs:

ALL tokens expire at 3:30 AM IST next day

So do NOT rely on JWT expiry decoding alone.

Correct validity check:
boolean valid =
    expiresAt.isAfter(Instant.now().plusSeconds(60))
    && profileApiReturns200();

6. Login Lifecycle State Machine (Final, Correct)
NOT_LOGGED_IN
    ↓
USER_AUTHENTICATED (mobile + PIN + TOTP)
    ↓
APP_AUTH_IN_PROGRESS
    ↓
TOKEN_ISSUED [per client_id]
    ↓
TOKEN_STORED [DB]
    ↓
TOKEN_VALIDATED [profile API]
    ↓
(Repeat until count == 6)
    ↓
FULLY_AUTHENTICATED
    ↓
DASHBOARD_ALLOWED

7. Final Login Confirmation Rule (NON-NEGOTIABLE)
boolean loginConfirmed =
    tokenRepository.countValidTokens() == REQUIRED_TOKENS
    && upstoxApi.profile(primaryToken).statusCode() == 200;


Only then:

Redirect to dashboard

Start websockets

Enable market data

Skip Selenium on restart

8. What Happens on Server Restart (Your Goal)

✅ Tokens loaded from DB
✅ Expiry validated
✅ API validated
✅ Selenium skipped
✅ User stays logged in

Until 3:30 AM IST, at which point:

Tokens expire

State → RELOGIN_REQUIRED

Selenium flow re-enabled

9. Optional (But Highly Recommended): Token Request API (v3)

For headless / operator-approved login, you can later migrate to:

POST /v3/login/auth/token/request/{client_id}


This:

Eliminates Selenium

Uses webhook

Is Upstox’s long-term direction

But your current Selenium-based flow is still valid.

10. Final Direct Answer
Do you need to provide client_id & client_secret?

✅ YES — per API / per app

Should they be in application.properties?

❌ NO

Should they be auto-discovered from env?

✅ YES

Can all 6 tokens be authenticated in one login?

✅ YES — via repeated authorize + token exchange

Will this prevent re-login on restart?

✅ YES — until 3:30 AM IST

What I strongly recommend next

Implement App Discovery Service

Implement Token Store + Validity Check

Implement Startup Auth Validator

Implement /auth/status endpoint

Implement Selenium skip logic

Add 3:15 AM auto re-auth scheduler