Below is a production-grade, Selenium-safe solution tailored for broker-style OAuth login automation (Upstox / Vega-type systems), followed by a formal login lifecycle state machine where the PRIMARY access token validity defines authentication health.

This avoids brittle UI assumptions and is safe against redirects, Cloudflare delays, and DOM changes.

PART 1 — Selenium-Safe Login Success Detection (Backend-Authoritative)
Design Principles (Critical)

Never trust URL change or page title

Never trust dashboard DOM visibility alone

Login success = PRIMARY access token issued AND validated

Final confirmation = authenticated API call returns 200

Step-by-Step Detection Strategy
Detection Signal Strength (in order)
Signal	Reliability
Access token captured	High
Token expiry parsed	High
Protected API success	Absolute
A. Capture PRIMARY Access Token (Selenium)
Token Sources (in priority order)

Network XHR response (OAuth callback)

Browser storage (LocalStorage / Cookies)

Redirect URI fragment / query

1. Enable Network Capture (Chrome DevTools)
DevTools devTools = ((ChromeDriver) driver).getDevTools();
devTools.createSession();

devTools.send(Network.enable(Optional.empty(), Optional.empty(), Optional.empty()));

2. Listen for OAuth Token Response
AtomicReference<String> accessTokenRef = new AtomicReference<>();

devTools.addListener(Network.responseReceived(), response -> {
    String url = response.getResponse().getUrl();

    if (url.contains("/oauth/token") || url.contains("/authorize")) {
        Network.GetResponseBodyResponse body =
            devTools.send(Network.getResponseBody(response.getRequestId()));

        if (body.getBody().contains("access_token")) {
            String token = extractAccessToken(body.getBody());
            accessTokenRef.set(token);
        }
    }
});

3. Fallback: Read from LocalStorage
JavascriptExecutor js = (JavascriptExecutor) driver;

String accessToken = (String) js.executeScript(
    "return window.localStorage.getItem('access_token');"
);

B. Validate PRIMARY Token (Non-UI Check)
1. Decode Token Expiry (JWT example)
DecodedJWT jwt = JWT.decode(accessToken);

Instant expiresAt = jwt.getExpiresAt().toInstant();
boolean valid = expiresAt.isAfter(Instant.now());

2. Call a Protected API (MANDATORY)
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.broker.com/v2/profile"))
    .header("Authorization", "Bearer " + accessToken)
    .GET()
    .build();

HttpResponse<String> response =
    HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());

boolean authenticated = response.statusCode() == 200;

C. Final Login Success Decision
boolean loginSuccessful =
        accessToken != null
    && tokenNotExpired(accessToken)
    && authenticatedApiCallSucceeded;


Only this condition authorizes redirect to dashboard or token persistence.

PART 2 — Login Lifecycle State Machine (PRIMARY Token Driven)

This state machine is backend-centric, automation-safe, and scheduler-ready.

State Definitions
┌──────────────┐
│ NOT_LOGGED_IN│
└──────┬───────┘
       │
       ▼
┌───────────────────┐
│ LOGIN_INITIATED   │
│ (Browser Started) │
└──────┬────────────┘
       │
       ▼
┌───────────────────┐
│ CREDENTIALS_SENT  │
│ (User/Automation) │
└──────┬────────────┘
       │
       ▼
┌───────────────────┐
│ SECOND_FACTOR     │
│ (OTP / CAPTCHA)  │
└──────┬────────────┘
       │
       ▼
┌──────────────────────────┐
│ TOKEN_ISSUED (PRIMARY)   │
│ access_token received   │
└──────┬──────────────────┘
       │
       ▼
┌──────────────────────────┐
│ TOKEN_VALIDATED          │
│ profile API = 200        │
└──────┬──────────────────┘
       │
       ▼
┌──────────────────────────┐
│ AUTHENTICATED            │
│ PRIMARY token valid      │
└──────┬──────────────────┘
       │
       ▼
┌──────────────────────────┐
│ DASHBOARD_ACCESS_GRANTED │
└──────────────────────────┘

State Transition Rules (Formal)
From State	Condition	To State
NOT_LOGGED_IN	Login triggered	LOGIN_INITIATED
LOGIN_INITIATED	Browser ready	CREDENTIALS_SENT
CREDENTIALS_SENT	OTP required	SECOND_FACTOR
SECOND_FACTOR	Token issued	TOKEN_ISSUED
TOKEN_ISSUED	Token expiry valid	TOKEN_VALIDATED
TOKEN_VALIDATED	API 200	AUTHENTICATED
AUTHENTICATED	UI redirect	DASHBOARD_ACCESS_GRANTED
Token Expiry Handling (PRIMARY Token)
AUTHENTICATED
    │
    ├── Token expired ──► TOKEN_EXPIRED
    │
    ├── Token near expiry ──► REFRESH_REQUIRED
    │
    └── API 401 ──► INVALIDATED

Expiry Threshold Policy (Recommended)
boolean needsRefresh =
    expiresAt.minus(Duration.ofMinutes(10)).isBefore(Instant.now());

Backend Guard Condition (Single Source of Truth)
boolean isAuthenticated() {
    return primaryToken != null
        && primaryToken.isValid()
        && profileApiReturns200();
}


UI redirection must never bypass this check.

Final Architectural Verdict

Login success detection

Backend-authoritative

Token-validated

API-verified

Dashboard access

Frontend redirect

Backend enforced

PRIMARY access token

Defines authentication lifecycle

Single determinant of login state