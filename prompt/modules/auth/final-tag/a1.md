Below is a complete, enterprise-grade implementation guide that integrates database-backed token persistence, multi-API configuration (1–6), validity checking, profile verification, selective regeneration, and operator choice, fully aligned with your existing Upstox V2 Enterprise Login Automation architecture.

This is written to be drop-in compatible with your current module and usable from:

CLI (headless / interactive)

Vite + React frontend

Any other frontend via REST

No assumptions are made beyond what you already have.

1. High-Level Flow (Authoritative)
Canonical Token Lifecycle Flow
START
  ↓
Load API Configs (ENV or DB)
  ↓
Load Existing Tokens from vega_trade.db
  ↓
DB Validity Check (created_at + validity_at)
  ↓
Upstox Profile Verification (GET /v2/user/profile)
  ↓
Classify Tokens:
   - VALID
   - EXPIRED (time-based)
   - INVALID (profile API failed)
  ↓
Present Summary to User
  ↓
User Decision:
   - Generate ALL
   - Generate ONLY INVALID
   - Generate SELECTED api_name(s)
   - Abort
  ↓
Run Selenium / v3 Flow for Selected APIs
  ↓
IMMEDIATELY Persist Token to DB (REPLACE MODE)
  ↓
Audit + State Update
END


This flow prevents unnecessary logins, respects broker limits, and keeps DB as the source of truth.

2. Database Integration (SQLite – Auto-Detected)
Database Location
<backend-root>/vega_trade.db


Auto-detected using:

Path dbPath = Paths.get(System.getProperty("user.dir"), "vega_trade.db");


No hardcoding.

2.1 Token Table (UNCHANGED – as requested)

You explicitly asked to keep this exact schema.
No changes required.

CREATE TABLE "upstox_tokens" (
    "id" integer PRIMARY KEY,
    "access_token" varchar(2000),
    "api_name" varchar(255) NOT NULL,
    "client_id" varchar(255),
    "client_secret" varchar(255),
    "created_at" timestamp,
    "expires_in" bigint,
    "is_primary" boolean,
    "last_refreshed" timestamp,
    "redirect_uri" varchar(255),
    "refresh_token" varchar(2000),
    "token_type" varchar(255),
    "api_index" integer,
    "generated_at" varchar(255),
    "is_active" integer,
    "purpose" varchar(255),
    "updated_at" bigint,
    "user_id" integer,
    "validity_at" varchar(255)
);

3. API Configuration Model (1–6 APIs)
Supported API Names (FIXED ENUM)
public enum ApiName {
    PRIMARY,
    WEBSOCKET1,
    WEBSOCKET2,
    WEBSOCKET3,
    OPTIONCHAIN1,
    OPTIONCHAIN2
}

3.1 Configuration Sources (Selectable)
Settings Flag
UPSTOX_CONFIG_SOURCE=ENV   # or DB


Default: ENV

3.2 ENV-Based Configuration (DEFAULT)
Required ENV Keys
UPSTOX_MOBILE_NUMBER=9599xxxxxx
UPSTOX_PIN=123456
UPSTOX_TOTP=BASE32SECRET
UPSTOX_REDIRECT_URI=http://localhost:28020/api/v1/auth/upstox/callback

# Optional
UPSTOX_NOTIFIER_WEBHOOK_URI=https://your-webhook

# API CONFIGS (1–6)
UPSTOX_CLIENT_ID_0=xxxx
UPSTOX_CLIENT_SECRET_0=xxxx
UPSTOX_API_NAME_0=PRIMARY

UPSTOX_CLIENT_ID_1=xxxx
UPSTOX_CLIENT_SECRET_1=xxxx
UPSTOX_API_NAME_1=WEBSOCKET1
...


Validation rules:

Max 6 entries

API_NAME must match enum

Index must be contiguous (0..N)

3.3 (Optional) API Config Table (If DB-Based)

If you choose DB storage:

CREATE TABLE upstox_api_configs (
    api_index INTEGER PRIMARY KEY,
    api_name VARCHAR(50) UNIQUE NOT NULL,
    client_id VARCHAR(255) NOT NULL,
    client_secret VARCHAR(255) NOT NULL,
    redirect_uri VARCHAR(255),
    is_primary BOOLEAN DEFAULT 0,
    is_enabled BOOLEAN DEFAULT 1,
    created_at BIGINT,
    updated_at BIGINT
);

4. Token Repository (Authoritative DB Layer)
UpstoxTokenRepository.java
public interface UpstoxTokenRepository {

    List<UpstoxTokenEntity> findAll();

    Optional<UpstoxTokenEntity> findByApiName(ApiName apiName);

    void upsertToken(UpstoxTokenEntity token);

    void deactivateToken(ApiName apiName);
}

Upsert Rule (CRITICAL)

One row per api_name

Replace token immediately after generation

Never store token in memory without persistence

4.1 Upsert SQL (Exact Behavior)
DELETE FROM upstox_tokens WHERE api_name = ?;

INSERT INTO upstox_tokens (
    access_token,
    api_name,
    client_id,
    client_secret,
    created_at,
    expires_in,
    is_primary,
    redirect_uri,
    token_type,
    api_index,
    generated_at,
    is_active,
    updated_at,
    validity_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1, ?, ?);

5. Token Validity Evaluation (2-Layer)
5.1 Layer 1 – DB Time Check
boolean isTimeValid(UpstoxTokenEntity t) {
    Instant now = Instant.now();
    Instant validity = LocalDateTime
        .parse(t.getValidityAt(), DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
        .atZone(ZoneId.systemDefault())
        .toInstant();
    return now.isBefore(validity);
}

5.2 Layer 2 – Profile API Verification
ProfileVerifierV2 (Extended)
public ProfileCheckResult verifyAccessToken(String token) {
    HttpRequest request = HttpRequest.newBuilder()
        .uri(URI.create("https://api.upstox.com/v2/user/profile"))
        .header("Authorization", "Bearer " + token)
        .header("Accept", "application/json")
        .build();

    HttpResponse<String> res = client.send(request, BodyHandlers.ofString());

    if (res.statusCode() == 200) return VALID;
    if (res.statusCode() == 401) return INVALID;
    return UNKNOWN;
}

6. Token Classification Result
class TokenStatusReport {
    ApiName apiName;
    boolean timeValid;
    boolean profileValid;
}


Final status:

✅ VALID → no regeneration needed

❌ INVALID → must regenerate

7. Operator Interaction (CLI + Frontend)
7.1 CLI Example
Token Status Summary:
----------------------------------
PRIMARY        : VALID
WEBSOCKET1    : VALID
WEBSOCKET2    : INVALID (401)
WEBSOCKET3    : EXPIRED
OPTIONCHAIN1  : VALID
OPTIONCHAIN2  : NOT FOUND

Valid Tokens    : 3
Invalid Tokens  : 3

Choose Action:
1. Generate ALL
2. Generate ONLY invalid
3. Generate selected (comma separated)
4. Abort

7.2 REST API (Frontend-Friendly)
GET /auth/upstox/tokens/status

Response:

{
  "valid": ["PRIMARY", "WEBSOCKET1", "OPTIONCHAIN1"],
  "invalid": ["WEBSOCKET2", "WEBSOCKET3"],
  "missing": ["OPTIONCHAIN2"]
}

POST /auth/upstox/tokens/generate
{
  "mode": "PARTIAL",
  "apiNames": ["WEBSOCKET2", "WEBSOCKET3"]
}


Modes:

ALL

INVALID_ONLY

PARTIAL

8. Selenium Integration Change (Single Line)
OAuthLoginAutomationV2.java

After successful token exchange:

tokenRepository.upsertToken(
    UpstoxTokenEntity.from(loginResult, apiConfig)
);


This happens before audit logging.

9. Frontend (Vite / React)
Suggested UX

Token status dashboard

Green / Red indicators

“Generate Missing” button

“Force Regenerate All” (danger)

CAPTCHA wait screen (operator only)

No Selenium exposed to frontend.

10. Security & Compliance (Non-Negotiable)

✔ Tokens written immediately
✔ CAPTCHA never auto-bypassed
✔ Profile API mandatory check
✔ DB is source of truth
✔ ENV secrets never logged
✔ One token per api_name enforced

11. Final Verdict

This design:

Scales to institutional use

Survives broker policy tightening

Supports automation without abuse

Cleanly separates operator intent from execution