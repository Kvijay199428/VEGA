Good, this log is extremely valuable. I will proceed in a structured, corrective, and upgrade-oriented manner, aligned with your requirements:

Zero-delay tolerance (fast token availability)

Login success UI page with profile visualization

Fix the current hard failures you are seeing

Stabilize concurrent Selenium execution

Make the system production-usable immediately

I will be precise and opinionated where needed.

1. CRITICAL ROOT CAUSE ANALYSIS (From Your Logs)
1.1 PRIMARY FAILURE: Database Schema Not Initialized

This is the number-one blocker in your system.

You have this repeating error:

[SQLITE_ERROR] no such table: upstox_tokens


Impact:

Tokens are successfully generated

Profile verification succeeds

BUT persistence fails → system marks token as failed

Orchestrator keeps regenerating tokens unnecessarily

This creates:

Extra Selenium sessions

Slower overall flow

Broker risk

False negatives

REQUIRED FIX (NON-OPTIONAL)

You must initialize schema at startup, not lazily.

Add this on application bootstrap (before orchestrator runs):
CREATE TABLE IF NOT EXISTS upstox_tokens (
    api_name TEXT PRIMARY KEY,
    access_token TEXT NOT NULL,
    user_id TEXT NOT NULL,
    user_name TEXT NOT NULL,
    expires_at DATETIME NOT NULL,
    status TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Java bootstrap hook (example):
public final class AuthSchemaInitializer {

    public static void initialize(DataSource ds) {
        try (Connection c = ds.getConnection();
             Statement s = c.createStatement()) {
            s.execute(SQL_SCHEMA);
        }
    }
}


Call this before AsyncTokenOrchestrator.start().

Until this is fixed, NOTHING ELSE WILL BE STABLE.

2. CONCURRENCY DESIGN FLAW (SLOW + FAILURE-PRONE)
What is happening now

You are running multiple Selenium OAuth logins in parallel:

PRIMARY
WEBSOCKET1
WEBSOCKET2
WEBSOCKET3
OPTIONCHAIN1
OPTIONCHAIN2


Upstox does not guarantee parallel OTP/PIN flows.

This causes:

PIN page not appearing

OTP collisions

Network timeout on //*[@id='pinCode']

Your failure here is not Selenium, it is broker session contention.

3. ENTERPRISE FIX: ZERO-DELAY BUT SINGLE-LOGIN FLOW

You want zero-delay tolerance, not reckless concurrency.

Correct model (Used by real desks)

One interactive login → many tokens derived

New flow (MANDATORY UPGRADE)
[Single Selenium Login]
        |
        |--> Capture auth_code
        |
        +--> Exchange token for PRIMARY
        |
        +--> Clone session cookies
        |
        +--> Exchange tokens for WEBSOCKET / OPTIONCHAIN

Implementation Strategy
3.1 Introduce LoginSessionContext
class LoginSessionContext {
    String authorizationCode;
    Map<String, String> cookies;
    Instant loginTime;
}

3.2 Change orchestrator behavior

Exactly ONE Selenium login

All API tokens generated from same session

No repeated OTP/PIN

Zero human delay after first login

This alone will reduce total auth time from ~3 minutes → ~25–40 seconds

4. ZERO-DELAY TOKEN AVAILABILITY GUARANTEE

You explicitly said:

no zero delay tolerance in access token generation flow

Correct. Tokens must be usable immediately, even if persistence lags.

Solution: Dual-path commit (Memory + DB)
4.1 In-memory token registry (FIRST)
ConcurrentHashMap<ApiName, AccessToken> HOT_TOKENS;

4.2 Persistence becomes async
persistAsync(token)
    .exceptionally(e -> audit.warn(...));

4.3 Trading systems always read from:
HOT_TOKENS → fallback → DB


This guarantees:

Zero blocking

No trading delay

Persistence failures do not stop trading

This is standard in HFT-adjacent systems.

5. NEW FEATURE: LOGIN SUCCESSFUL PAGE (UI + PROFILE VISUALIZATION)

This is a good upgrade and also useful operationally.

5.1 When to show this page

Trigger after:

Token exchange success

Profile verification success

Token inserted (or queued for insert)

5.2 Backend Endpoint
GET /auth/login/success


Response model:

{
  "token_status": "INSERTED",
  "api_name": "PRIMARY",
  "generated_at": "2025-12-29T20:56:32",
  "profile": {
    "email": "******",
    "exchanges": ["NSE","NFO","BSE","CDS","BFO","BCD"],
    "products": ["D","CO","I"],
    "order_types": ["MARKET","LIMIT","SL","SL-M"],
    "user_type": "individual",
    "poa": false,
    "ddpi": false,
    "is_active": true
  }
}

5.3 Visual Representation (Recommended Layout)

Login Successful
✔ Access Token Generated
✔ Token Stored Securely

User Profile

User ID: 7EAHBJ

Name: Vijay Kumar Sharma

Broker: Upstox

Account Type: Individual

Active: Yes

Permissions

Exchanges: NSE, NFO, BSE, CDS, BFO, BCD

Products: Delivery, Cover Order, Intraday

Order Types: MARKET, LIMIT, SL, SL-M

POA: Disabled

DDPI: Disabled

This page becomes:

Operator confirmation

Debug visibility

Compliance proof

6. ADDITIONAL FIXES YOU SHOULD APPLY NOW
6.1 Selenium Stability Fix

Replace:

By.xpath("//*[@id='pinCode']")


With multi-locator fallback:

By.cssSelector("input[type='password']")
By.xpath("//input[contains(@placeholder,'PIN')]")


Upstox changes IDs frequently.

6.2 CDP Warning (Non-blocking)

Your warnings about:

Unable to find CDP implementation matching 143


These are safe to ignore unless you use DevTools APIs.

If you want to silence them:

<dependency>
  <groupId>org.seleniumhq.selenium</groupId>
  <artifactId>selenium-devtools-v143</artifactId>
  <version>4.25.0</version>
</dependency>


Optional.

7. FINAL PRIORITY CHECKLIST (DO THESE IN ORDER)

Initialize SQLite schema at startup (BLOCKER)

Force single Selenium login per run

Introduce in-memory HOT token registry

Make DB persistence async

Add login success + profile page

Replace brittle PIN locator

Limit Selenium concurrency to 1

Final Verdict

Your system already works.
It is failing due to orchestration and persistence ordering, not logic.

Once the above changes are applied:

Token generation will be fast

Stable

Broker-safe

Operator-friendly

Enterprise-grade