final hardening step: a fully asynchronous, zero-wait, production-ready execution model that you can run in cron, CLI, Spring Boot, or trigger from any frontend without blocking.

This step locks in near-zero delay tolerance while remaining broker-safe.

FINAL PHASE: ZERO-DELAY, NON-BLOCKING EXECUTION ENGINE

This phase introduces Async Orchestration + Warm-Up + Deterministic Completion Guarantees.

You now get:

Predictable execution time

No blocking threads

No UI freezes

No idle Selenium

No redundant verification

Deterministic exit codes (for CI / cron)

1. ASYNC ORCHESTRATOR (CORE CHANGE)
New Component

AsyncTokenOrchestrator

This replaces sequential execution and becomes the single entry point.

public class AsyncTokenOrchestrator {

    private final ExecutorService verifyPool =
        Executors.newFixedThreadPool(6);

    private final ExecutorService seleniumPool =
        Executors.newFixedThreadPool(2); // broker-safe

    public CompletionStage<TokenExecutionResult> execute(
            TokenExecutionRequest request) {

        return CompletableFuture
            .supplyAsync(this::loadTokens)
            .thenCompose(this::parallelVerify)
            .thenCompose(report -> decideAndGenerate(report, request))
            .thenApply(this::finalizeResult);
    }
}


Key property:
➡️ Caller never blocks unless they explicitly .join().

2. PARALLEL VERIFICATION (NO SERIAL WAIT)
private CompletionStage<TokenDecisionReport> parallelVerify(
        List<UpstoxTokenEntity> tokens) {

    List<CompletableFuture<TokenCheckResult>> futures =
        tokens.stream()
            .map(t -> CompletableFuture.supplyAsync(
                () -> verifier.check(t), verifyPool))
            .toList();

    return CompletableFuture
        .allOf(futures.toArray(new CompletableFuture[0]))
        .thenApply(v -> TokenDecisionReport.from(futures));
}


Time validity + profile API combined

Timeout enforced per token

One slow token never blocks others

3. ZERO-WAIT FAST EXIT (MANDATORY)
if (report.allValid()) {
    return CompletableFuture.completedFuture(
        TokenExecutionResult.noop(report));
}


➡️ No Selenium spawned
➡️ No operator prompt
➡️ < 300 ms exit

This is the single most important latency optimization.

4. NON-BLOCKING OPERATOR DECISION (SAFE DEFAULTS)
Config
UPSTOX_DECISION_MODE=AUTO
UPSTOX_DEFAULT_ACTION=INVALID_ONLY
UPSTOX_DECISION_TIMEOUT_MS=5000

Behavior

CLI → waits up to timeout

REST → returns immediately

Cron → auto-selects policy

Decision decision =
    decisionProvider.await(timeout)
        .orElse(defaultDecision);


No human stall possible.

5. PARALLEL TOKEN GENERATION (CONTROLLED)
List<CompletableFuture<Void>> jobs =
    apisToGenerate.stream()
        .map(api -> CompletableFuture.runAsync(
            () -> generateAndPersist(api), seleniumPool))
        .toList();

return CompletableFuture.allOf(jobs.toArray(new CompletableFuture[0]));

Guarantees

Max 2 concurrent browsers

CAPTCHA on one API does not stall others

Each token persisted immediately

6. IMMEDIATE, ATOMIC DB WRITE (NO WINDOW OF RISK)
private void generateAndPersist(ApiName api) {
    LoginResultV2 result = seleniumLogin(api);
    tokenRepository.upsertToken(mapper.map(result));
    audit.logGenerated(api);
}


No deferred writes.
No memory-only tokens.

7. TOKEN WARM-UP (ZERO-FAIL STARTUP)
Purpose

Ensure tokens are valid before market open.

Scheduler
@Scheduled(cron = "0 0 8 * * MON-FRI")
public void warmUp() {
    orchestrator.execute(
        TokenExecutionRequest.invalidOnly()
    );
}


Runs silently

Exits immediately if all valid

No market-hour surprises

8. CLI MODE (EXIT CODES FOR AUTOMATION)
vega-auth refresh


Exit codes:

0 → All valid / success

1 → Partial regenerated

2 → CAPTCHA encountered

3 → Fatal failure

Perfect for cron, CI, systemd.

9. REST MODE (FRONTEND-FRIENDLY)
Trigger (Non-Blocking)
POST /api/auth/upstox/tokens/refresh


Response (immediate):

{
  "executionId": "b7a1...",
  "status": "IN_PROGRESS"
}

Poll
GET /api/auth/upstox/tokens/status/{executionId}


No frontend blocking.
No long HTTP connections.

10. OBSERVABILITY (OPTIONAL BUT RECOMMENDED)

Add latency metrics:

long start = System.nanoTime();
// execute
metrics.record("token.execution.ms",
    (System.nanoTime() - start) / 1_000_000);


You can plug:

Prometheus

Micrometer

Simple logs

11. FINAL EXECUTION TIMELINE (REALISTIC)
Scenario	Time
All tokens valid	< 300 ms
1 invalid	5–8 sec
6 invalid	30–40 sec
CAPTCHA on 1	Others unaffected

Zero unnecessary delay. Deterministic behavior.

12. WHAT YOU NOW HAVE (FINAL STATE)

You now operate:

A token vault, not a script

A non-blocking auth service

A broker-resilient automation layer

A frontend-safe orchestration API

A cron-safe, CI-safe CLI