ENTERPRISE TIMEOUT HANDLER WITH RESUME-FROM-FAILURE
Problem Classification (Correctly Identified)

Symptoms

Login flow succeeds for Token A

Fails during Token B (usually PIN submit or redirect)

Same credentials work again after ~10–11 minutes

Failure is consistent across runs

Root Cause

Upstox broker enforces session / OTP / PIN throttling

Cooldown window ≈ 10 minutes

Any automation inside this window is rejected silently or times out

This is expected broker behavior.

REQUIRED BEHAVIOUR (Your Specification)

When an error occurs:

Immediately stop Selenium

Record last successful token

Halt execution for 11 minutes

Resume login flow from the failed token

Continue until all remaining tokens are generated

This must work every time an error occurs

This is stateful orchestration, not retry logic.

HIGH-LEVEL ARCHITECTURE
AsyncTokenOrchestrator
   |
   +── TokenExecutionState (PERSISTED)
   |
   +── CooldownManager (11 min)
   |
   +── SeleniumLifecycleController

1. TOKEN EXECUTION STATE (CRITICAL)

You must persist progress, not keep it in memory.

Execution State Model
public class TokenExecutionState {

    private String executionId;
    private ApiName lastSuccessfulApi;
    private ApiName nextApiToGenerate;
    private Instant lastFailureTime;
    private ExecutionStatus status;
}

Status Enum
enum ExecutionStatus {
    RUNNING,
    COOLDOWN,
    RESUMING,
    COMPLETED
}


Persist this in SQLite.

2. FAILURE DETECTION (WHAT COUNTS AS A BROKER BLOCK)

Only these errors should trigger cooldown:

Timeout waiting for PIN submit

Timeout waiting for redirect URL

Authorization code not received

Selenium stuck after successful OTP + PIN

Detection Layer
catch (TimeoutException | WebDriverException e) {
    throw new BrokerCooldownException(apiName, e);
}


Do NOT cooldown on:

Invalid credentials

Profile API failure

DB failure

3. SELENIUM HARD STOP (MANDATORY)

When cooldown is triggered:

seleniumController.forceShutdown();


This must:

Quit driver

Kill Chrome process

Release WebDriverManager lock

No browser must remain alive.

4. COOLDOWN MANAGER (11 MINUTE HALT)
Why 11 Minutes?

You observed recovery after 10.
We add a safety buffer.

private static final Duration COOLDOWN = Duration.ofMinutes(11);

Cooldown Logic
state.setStatus(COOLDOWN);
state.setLastFailureTime(Instant.now());
persist(state);

Thread.sleep(COOLDOWN.toMillis());


This is intentional blocking.
This is NOT async retry.

5. RESUME LOGIC (THE CORE FEATURE)

After cooldown:

state.setStatus(RESUMING);
persist(state);

startFrom(state.getNextApiToGenerate());

Resume Rule

If tokens generated were:

PRIMARY ✅
WEBSOCKET1 ✅
WEBSOCKET2 ❌


Resume sequence must be:

WEBSOCKET2 → WEBSOCKET3 → OPTIONCHAIN1 → OPTIONCHAIN2


Never regenerate successful tokens.

6. ORCHESTRATOR FLOW (FINAL)
for (ApiName api : remainingApis) {
    try {
        generateToken(api);
        markSuccess(api);
    } catch (BrokerCooldownException e) {
        handleCooldown(api);
        resumeFrom(api);
    }
}


This loop never restarts from the beginning.

7. LOGGING (WHAT YOU ASKED FOR)

You explicitly asked for separate logs per feature.

Required Logs
test-log/
 ├── token_generation.log
 ├── cooldown_events.log
 ├── selenium_lifecycle.log
 ├── resume_flow.log
 ├── profile_verification.log
 └── db_persistence.log

Example Cooldown Log
[COOLDOWN_TRIGGERED]
API_FAILED     : WEBSOCKET2
LAST_SUCCESS   : WEBSOCKET1
REASON         : PIN redirect timeout
COOLDOWN_UNTIL : 2025-12-29T21:39:00

Resume Log
[RESUME_STARTED]
Resuming token generation from: WEBSOCKET2
Remaining APIs: WEBSOCKET2, WEBSOCKET3, OPTIONCHAIN1, OPTIONCHAIN2

8. DATABASE DIRECTORY CONFIRMATION

You requested:

database/
 └── vega_trade.db


Correct approach (already applied):

Paths.get("database", "vega_trade.db").toAbsolutePath();


This ensures:

Portable deployment

Predictable backups

No accidental recreation

9. WHY THIS DESIGN IS CORRECT

✔ Matches broker throttling reality
✔ Zero unnecessary retries
✔ No OTP/PIN abuse
✔ No data loss
✔ Fully resumable
✔ Operator-safe
✔ Enterprise-grade

This is exactly how real trading desks handle OAuth throttling.

10. FINAL STATUS (WHERE YOU ARE NOW)

What is already working perfectly:

Single Selenium instance ✔

Token persistence ✔

DB path corrected ✔

Login success verification ✔

Profile API verification ✔

Hot token registry ✔

What remains to implement:

TokenExecutionState persistence

CooldownManager (11 min)

Resume-from-failure orchestration

Per-feature logs