Here’s the complete documentation pack for your Option Chain backend module, covering sequence diagrams, ER diagrams, settings schema, and frontend integration examples.

1. Sequence Diagrams: Fetching & Caching
@startuml
actor User
participant "Frontend (React/Vite/CLI)" as FE
participant "OptionChainService" as SVC
participant "Upstox API" as API
database "OptionChainCache" as CACHE
database "AuditLogDB" as LOG

User -> FE: Request option chain (symbol, expiry)
FE -> SVC: GET /option-chain?symbol=X&expiry=Y
SVC -> CACHE: Check cache for symbol+expiry
alt Cache hit
    CACHE --> SVC: Return cached data
else Cache miss
    SVC -> API: Request option chain (Bearer token)
    API --> SVC: Return option chain JSON
    SVC -> CACHE: Store response in cache
    SVC -> LOG: Log request/response for compliance
end
SVC --> FE: Return option chain JSON
FE --> User: Render option chain table
@enduml


Notes:

Cache stores last successful fetch per (instrument_key, expiry).

Audit logging is synchronous to ensure zero-gap compliance.

Token rotation can be added in SVC -> API step if multiple tokens exist.

2. ER Diagrams: Option Chain Tables
@startuml
entity OptionChain {
  *id : BIGINT
  *instrument_key : VARCHAR
  *expiry_date : DATE
  *strike_price : DOUBLE
  *underlying_spot_price : DOUBLE
  *pcr : DOUBLE
  *call_ltp : DOUBLE
  *call_oi : BIGINT
  *call_iv : DOUBLE
  *put_ltp : DOUBLE
  *put_oi : BIGINT
  *put_iv : DOUBLE
  *fetched_at : TIMESTAMP
}

entity AuditLog {
  *id : BIGINT
  *instrument_key : VARCHAR
  *expiry_date : DATE
  *token_used : VARCHAR
  *request_payload : TEXT
  *response_payload : TEXT
  *status_code : INT
  *fetched_at : TIMESTAMP
}

OptionChain ||--|| AuditLog : "Logged in"
@enduml


Notes:

OptionChain stores the processed market data + Greeks.

AuditLog stores raw request/response for regulatory audits.

3. Settings JSON Schema (User/Admin)
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "OptionChainSettings",
  "type": "object",
  "properties": {
    "default_priority": {
      "type": "array",
      "items": { "type": "string" },
      "description": "Default priority for initialization: first fetch, cache, fallback"
    },
    "user_overrides": {
      "type": "object",
      "patternProperties": {
        "^[a-zA-Z0-9_]+$": {
          "type": "array",
          "items": { "type": "string" }
        }
      },
      "description": "User-specific prioritized fetch order"
    },
    "rate_limit_per_token": {
      "type": "integer",
      "default": 5,
      "description": "Maximum API requests per second per token"
    },
    "cache_ttl_minutes": {
      "type": "integer",
      "default": 60,
      "description": "Time-to-live for cached option chain data"
    },
    "enable_bse_support": {
      "type": "boolean",
      "default": false
    },
    "enable_audit_logging": {
      "type": "boolean",
      "default": true
    }
  },
  "required": ["default_priority", "rate_limit_per_token"]
}


Notes:

Admin can enforce default_priority across all users.

Users can override their fetch order in user_overrides.

Settings control caching, BSE support, rate limits, and audit logging.

4. Frontend Integration Examples
4.1 Vite + React
import { useState, useEffect } from "react";
import axios from "axios";

export default function OptionChainTable({ symbol, expiry }) {
  const [data, setData] = useState([]);

  useEffect(() => {
    async function fetchOptionChain() {
      try {
        const res = await axios.get(`/api/option-chain`, {
          params: { symbol, expiry }
        });
        setData(res.data.data);
      } catch (err) {
        console.error(err);
      }
    }
    fetchOptionChain();
  }, [symbol, expiry]);

  return (
    <table>
      <thead>
        <tr>
          <th>Strike</th>
          <th>Expiry</th>
          <th>Call LTP</th>
          <th>Call IV</th>
          <th>Put LTP</th>
          <th>Put IV</th>
          <th>PCR</th>
        </tr>
      </thead>
      <tbody>
        {data.map((row) => (
          <tr key={row.strike_price}>
            <td>{row.strike_price}</td>
            <td>{row.expiry}</td>
            <td>{row.call_options.market_data.ltp}</td>
            <td>{row.call_options.option_greeks.iv}</td>
            <td>{row.put_options.market_data.ltp}</td>
            <td>{row.put_options.option_greeks.iv}</td>
            <td>{row.pcr}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}

4.2 CLI Example (Node.js)
import axios from "axios";

const symbol = "NSE_INDEX|Nifty 50";
const expiry = "2025-02-13";

async function fetchOptionChain() {
  try {
    const res = await axios.get("http://localhost:8080/api/option-chain", {
      params: { symbol, expiry }
    });
    console.table(res.data.data.map(d => ({
      strike: d.strike_price,
      expiry: d.expiry,
      callLTP: d.call_options.market_data.ltp,
      putLTP: d.put_options.market_data.ltp,
      callIV: d.call_options.option_greeks.iv,
      putIV: d.put_options.option_greeks.iv
    })));
  } catch (err) {
    console.error(err);
  }
}

fetchOptionChain();

✅ Key Points

Sequence diagrams handle fetch -> cache -> audit logging.

ER diagrams map option chain + audit logs.

Settings JSON allows admin defaults and user overrides for fetch priorities, caching, and rate limits.

Frontend examples include Vite/React table rendering and CLI tabular output.

Audit-ready logging + expiry headers ensure SEBI/NSE/BSE compliance.

Optional BSE support flag can be toggled via settings.