enterprise-grade design and implementation guide to extend your Option Chain module into a real-time streaming, delta-aware, multi-consumer feed, aligned with how professional market-data platforms (Bloomberg-style, NSE-TBT-style, broker OMS feeds) are built.

This is written to fit directly into your existing architecture (OptionChainFeedStreamV3, RMS, multi-broker adapters, frontend via Vite/React, CLI, REST), without breaking SEBI/NSE constraints.

Enterprise Option Chain Streaming Architecture (V3+)
Design Goals

Single authoritative option chain structure

Always maintained in backend as OptionChainFeedStreamV3

Real-time delivery

WebSocket-based (industry-standard)

Delta-based updates

Only changed fields are transmitted

Heartbeat-driven reliability

Ping/Pong health + gap detection

Multi-consumer friendly

Frontend, analytics, RMS, audit all consume from the same stream

Regulatory safe

Deterministic, auditable, no hidden state

1. WebSocket Model (Enterprise-Grade Choice)
Chosen Model

Stateful WebSocket with Delta Frames + Snapshot Bootstrap

This is the same pattern used by:

NSE TBT

Bloomberg B-PIPE

Zerodha Kite Ticker

Fyers WebSocket

Why not SSE / Polling
Method	Issue
REST polling	High latency, rate-limit risk
SSE	One-way only
Raw TCP	Compliance complexity
WebSocket	✅ Bidirectional, heartbeat, scalable
2. High-Level Component Architecture
┌────────────────────────────┐
│ Broker Adapters            │
│ (Upstox / BSE / Others)    │
└─────────────┬──────────────┘
              │
              ▼
┌────────────────────────────┐
│ OptionChainIngestor        │
│ - Normalization            │
│ - Validation               │
│ - RMS pre-check            │
└─────────────┬──────────────┘
              │
              ▼
┌──────────────────────────────────────────┐
│ OptionChainFeedStreamV3 (Authoritative)  │
│ - Full state snapshot                    │
│ - Versioned per instrument+expiry       │
│ - In-memory + optional Redis mirror      │
└─────────────┬────────────────────────────┘
              │
      ┌───────┼───────────────┐
      ▼       ▼               ▼
┌────────┐ ┌──────────┐ ┌──────────┐
│ WS API │ │ Analytics │ │ RMS      │
│ Server │ │ Modules   │ │ Engine   │
└────────┘ └──────────┘ └──────────┘

3. OptionChainFeedStreamV3 (Core Object)

This is always complete and never partial.

class OptionChainFeedStreamV3 {

    String underlyingKey;
    LocalDate expiry;
    long sequenceNumber;
    Instant lastUpdated;

    Map<Integer, StrikeNode> strikes; // strike_price → node
}

StrikeNode
class StrikeNode {
    int strikePrice;
    OptionLeg call;
    OptionLeg put;
}

OptionLeg
class OptionLeg {
    String instrumentKey;
    MarketData marketData;
    OptionGreeks greeks;
}


This structure never changes.
All updates modify this object first, then propagate outward.

4. Delta-Based Update Engine (Field-Level Updates)
Delta Detection Rule

Only emit fields that changed since last sequence.

Example

Previous:

ltp=200, oi=12323, volume=213


New:

ltp=201, oi=12323, volume=214

Delta Frame Produced
{
  "type": "DELTA",
  "seq": 184291,
  "instrument_key": "NSE_FO|51059",
  "fields": {
    "market_data.ltp": 201,
    "market_data.volume": 214
  }
}


No unchanged fields are transmitted.

5. WebSocket Message Protocol
5.1 Bootstrap Snapshot (Mandatory)

Sent once per subscription.

{
  "type": "SNAPSHOT",
  "seq": 184200,
  "payload": { /* full option chain object */ }
}


Frontend must not render deltas before snapshot.

5.2 Delta Updates
{
  "type": "DELTA",
  "seq": 184201,
  "strike": 21100,
  "leg": "CALL",
  "instrument_key": "NSE_FO|51059",
  "fields": {
    "market_data.ltp": 2449.9,
    "market_data.oi": 760
  }
}

5.3 Heartbeat (Ping/Pong)
Server → Client
{
  "type": "PING",
  "ts": 1739623921000
}

Client → Server
{
  "type": "PONG",
  "ts": 1739623921000
}

Heartbeat Rules

Interval: 3 seconds

Missed 2 heartbeats → reconnect

Reconnect triggers fresh SNAPSHOT

6. Separate Data Feeder (Frontend-Optimized)
Why a Feeder Layer

Frontend should never mutate core stream.

Flow
OptionChainFeedStreamV3
        │
        ▼
OptionChainFeeder
        │
        ├── Normalized UI rows
        ├── PCR aggregation
        ├── ATM/ITM/OTM tagging
        ├── Highlight logic
        ▼
Frontend Consumers

Feeder Output Example
{
  "strike": 21100,
  "call": {
    "ltp": 2449.9,
    "oi": 760,
    "delta": 0.74
  },
  "put": {
    "ltp": 0.3,
    "oi": 5636475
  },
  "moneyness": "ATM"
}


The core structure remains untouched.

7. WebSocket Scaling & Enterprise Controls
Concurrency

One WS connection per user

One feed per (symbol, expiry)

Fan-out via internal event bus

Backpressure

Drop intermediate deltas if client lags

Always preserve latest state

Security

JWT bound to:

User

Allowed symbols

Expiries

Read-only feed

No order actions

8. RMS & Compliance Integration
RMS Hooks

Strike disablement before emit

Frozen instruments filtered

BSE/NSE expiry validation

Audit Logging

Every WS frame logged as:

seq | user_id | instrument | expiry | fields_changed | latency


Zero delay, append-only.

9. Frontend Integration (Vite + React)
Connection
const ws = new WebSocket("wss://api/ws/option-chain");

ws.onmessage = (msg) => {
  const event = JSON.parse(msg.data);
  if (event.type === "SNAPSHOT") initState(event.payload);
  if (event.type === "DELTA") applyDelta(event);
};

Delta Apply Rule

Update only touched fields

No full re-render

Row-level reconciliation

10. CLI Consumer

CLI subscribes the same way but renders:

STRIKE | CALL LTP | CALL OI | PUT LTP | PUT OI

11. Failure & Recovery Model
Scenario	Action
WS disconnect	Reconnect
Seq gap	Force SNAPSHOT
Broker lag	Cache-based deltas
Token expiry	Silent reconnect
12. Versioning Strategy

Stream version: OptionChainFeedStreamV3

WS protocol versioned in header

Backward compatible deltas

Final Summary

You now have:

Authoritative option chain state

Delta-based WebSocket streaming

Heartbeat-driven reliability

Separate frontend feeder

RMS + audit-safe architecture

Industry-grade design

This design is production-safe, regulator-safe, and scalable.