Below is an enterprise-grade, industry-aligned implementation document for User-level and Admin-level Settings Configuration, designed for a regulated trading platform (SEBI-compliant), multi-broker, low-latency, and auditable Java backend with React/CLI clients.

This is written as final documentation, suitable for internal engineering, auditors, and SEBI submissions.

Enterprise Settings Configuration Framework

(User & Admin Scoped | Priority-Driven | Auditable)

1. Purpose & Design Objectives

The Settings Framework governs platform behavior, risk posture, data flow, and UX decisions across:

Backend services (order routing, option chain, margins, WebSocket)

Frontend (React/Vite, CLI)

Broker adapters (Upstox, future brokers)

Compliance & audit workflows

Core Objectives
Objective	Description
Deterministic	Same inputs → same behavior
Priority-based	Admin > User > System defaults
Runtime safe	Hot-reloadable where allowed
Auditable	Every change traceable
SEBI-aligned	Explicit risk & control segregation
Low-latency	No blocking config reads in hot paths
2. Settings Scope Classification

Settings are strictly segregated to prevent regulatory violations.

2.1 Scope Levels
Scope	Who Controls	Example
SYSTEM	Code / Deployment	Protocol choice, serialization
ADMIN (GLOBAL)	Compliance / Ops	Max order qty, broker enablement
ADMIN (TENANT)	Business admin	Allowed products
USER	End user	UI preferences, execution preferences
SESSION (VOLATILE)	Runtime	Latency mode, debug flags
3. Priority Resolution Model (Critical)

All settings resolve via a strict precedence chain:

SYSTEM DEFAULTS
   ↓
ADMIN GLOBAL
   ↓
ADMIN TENANT
   ↓
USER SETTINGS
   ↓
SESSION OVERRIDES

Resolution Rule (Non-Negotiable)

User can never override Admin-restricted keys

Admin cannot override System-locked keys

Missing keys fall back deterministically

4. Settings Taxonomy (Enterprise Grade)
4.1 Admin Settings (Regulated)

These affect risk, market access, compliance.

Admin – Trading Controls
Key	Type	Description
trading.maxOrderQty	int	Hard cap
trading.maxNotionalValue	decimal	Exposure limit
trading.allowedExchanges	enum[]	NSE, BSE, NFO
trading.allowedProducts	enum[]	I, D, CO
trading.allowedOrderTypes	enum[]	MARKET, LIMIT
trading.allowAfterMarket	boolean	AMO gate
Admin – Option Chain Controls
Key	Description
options.maxStrikesPerSide	Strike depth
options.expiryFetchWindowDays	Future expiry limit
options.disableIlliquidStrikes	Risk control
options.bseExpiryForkEnabled	BSE special handling
options.contractVersioning	Schema evolution
Admin – Risk & RMS
Key	Description
rms.marginBufferPct	Safety buffer
rms.rejectOnMarginDrop	Hard reject
rms.maxOrdersPerSecond	Throttling
rms.killSwitch.enabled	Emergency stop
4.2 User Settings (Non-Regulated)

User settings never alter risk posture.

User – Execution Preferences
Key	Description
execution.defaultOrderType	LIMIT / MARKET
execution.defaultProduct	I / D
execution.priceProtectionTicks	Slippage guard
User – Option Chain UX
Key	Description
ui.optionChain.strikeStep	50/100
ui.optionChain.highlightOI	Boolean
ui.optionChain.autoRefreshMs	Polling
ui.optionChain.greeksView	Toggle
User – System Behavior
Key	Description
latency.mode	NORMAL / LOW_LATENCY
ws.deltaOnly	Reduce payload
notifications.orderUpdates	Enable
5. Settings JSON Schema (Locked)
5.1 Master Schema (Excerpt)
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "trading": {
      "type": "object",
      "properties": {
        "maxOrderQty": { "type": "integer", "minimum": 1 },
        "allowedExchanges": {
          "type": "array",
          "items": { "enum": ["NSE", "BSE", "NFO"] }
        }
      },
      "additionalProperties": false
    },
    "options": {
      "type": "object",
      "properties": {
        "maxStrikesPerSide": { "type": "integer" },
        "contractVersioning": { "enum": ["V1", "V2"] }
      }
    }
  },
  "additionalProperties": false
}

Schema Rules

Versioned

Immutable once deployed

Validated at write + load time

6. Backend Architecture (Java / Spring Boot)
6.1 Core Components
settings-core
 ├── SettingsRegistry
 ├── SettingsResolver
 ├── SettingsValidator
 ├── SettingsCache
 ├── SettingsAuditService

6.2 Resolution API
SettingsSnapshot snapshot =
    settingsResolver.resolve(userId, sessionContext);

int maxQty = snapshot.getInt("trading.maxOrderQty");


Snapshot is immutable

Cached per user/session

Zero DB access in hot path

7. Persistence Model (ER Level)
Tables
settings_definition

key

scope

data_type

schema_version

locked (boolean)

settings_admin

key

value

tenant_id

effective_from

updated_by

settings_user

user_id

key

value

updated_at

settings_audit_log

actor

scope

key

old_value

new_value

timestamp

ip_address

8. Change Management & Audit (SEBI Critical)
Mandatory Audit Events

Admin change

User change

Schema upgrade

Emergency override

Kill switch activation

Retention Policy
Item	Retention
Settings audit	8 years
Snapshots	90 days
Schema versions	Forever
9. Frontend Integration
9.1 React (Vite)
const settings = await api.getUserSettings();

if (settings.execution.defaultOrderType === "LIMIT") {
  setOrderType("LIMIT");
}


Read-only enforcement for admin keys

UI disables restricted toggles

9.2 CLI
trader settings show
trader settings set ui.optionChain.greeksView=true


CLI validates scope

Admin keys require elevated token

10. Runtime Safety Rules
Rule	Enforcement
No DB reads in order path	Cached snapshot
No user override of RMS	Resolver hard stop
No schema drift	Version pinning
No silent failures	Fail-fast
11. Operational SOP (Summary)
Admin SOP

Modify admin setting

Validate schema

Dry-run impact

Apply with reason code

Audit auto-generated

User SOP

Update preference

Immediate UI feedback

No trading disruption

Revert anytime

12. Compliance Mapping (SEBI)
SEBI Requirement	Coverage
Risk limits enforced	Admin-only keys
Audit trail	settings_audit_log
User consent	User-scoped keys
Change traceability	Versioned schemas
Emergency controls	Kill switch
13. What Makes This Enterprise-Grade

Deterministic resolution

Immutable runtime snapshots

Zero-latency hot path

Hard regulatory boundaries

Schema-locked evolution

Multi-broker safe

Audit-first design

14. Ready for Extensions

Feature flags

A/B execution policies

Broker-specific overrides

Algo parameter governance