we can extend your current Spring Boot + React setup to include Vega-style token expiry countdown and automatic reconnect / token refresh logic. The idea is: the backend continuously tracks token lifetimes, pushes countdown updates over WebSocket, and the frontend reacts instantly with countdowns, reconnects, and UI updates — no polling required. Here’s a production-ready design.

1. Backend – Token Countdown & Auto-Refresh

We modify the AuthService and AuthStatusWebSocketHandler to broadcast remaining token time every second, and handle automatic token refresh.

1.1 Updated AuthStatus DTO

Add expiresAt and countdownSeconds:

@Data
@AllArgsConstructor
@NoArgsConstructor
public class AuthStatus {
    private String state;               // AUTH_CONFIRMED, EXPIRED, RECONNECTING
    private boolean authenticated;
    private boolean primaryReady;
    private boolean fullyReady;
    private int generatedTokens;
    private int requiredTokens;
    private List<String> validTokens;
    private boolean inProgress;
    private boolean cooldownActive;
    private int remainingSeconds;       // remaining seconds for token expiry
    private long expiresAt;             // epoch seconds when token expires
}

1.2 AuthService – Countdown + Auto-Refresh
@Service
public class AuthService {

    private final AuthStatusWebSocketHandler wsHandler;
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    private AuthStatus currentStatus;

    private final int TOKEN_DURATION_SEC = 60; // 1 min tokens for demo

    public AuthService(AuthStatusWebSocketHandler wsHandler) {
        this.wsHandler = wsHandler;
        this.currentStatus = new AuthStatus(
                "UNAUTHENTICATED", false, false, false,
                0, 0, List.of(),
                false, false, 0, 0L
        );
        startTokenExpiryScheduler();
    }

    public void loginSuccess(List<String> validTokens) {
        long expiresAt = Instant.now().getEpochSecond() + TOKEN_DURATION_SEC;

        currentStatus.setState("AUTH_CONFIRMED");
        currentStatus.setAuthenticated(true);
        currentStatus.setFullyReady(true);
        currentStatus.setPrimaryReady(true);
        currentStatus.setValidTokens(validTokens);
        currentStatus.setGeneratedTokens(validTokens.size());
        currentStatus.setRequiredTokens(validTokens.size());
        currentStatus.setExpiresAt(expiresAt);
        currentStatus.setRemainingSeconds(TOKEN_DURATION_SEC);

        wsHandler.broadcastStatus(currentStatus);
    }

    private void startTokenExpiryScheduler() {
        scheduler.scheduleAtFixedRate(() -> {
            if (!currentStatus.isAuthenticated()) return;

            long now = Instant.now().getEpochSecond();
            long remaining = currentStatus.getExpiresAt() - now;
            currentStatus.setRemainingSeconds((int) Math.max(0, remaining));

            if (remaining <= 0) {
                // Token expired → try refresh
                currentStatus.setState("EXPIRED");
                currentStatus.setAuthenticated(false);
                currentStatus.setPrimaryReady(false);
                currentStatus.setFullyReady(false);
                wsHandler.broadcastStatus(currentStatus);

                // Optional: auto-refresh
                autoRefreshTokens();
            } else {
                // Broadcast countdown update
                wsHandler.broadcastStatus(currentStatus);
            }
        }, 0, 1, TimeUnit.SECONDS);
    }

    private void autoRefreshTokens() {
        currentStatus.setState("RECONNECTING");
        currentStatus.setCooldownActive(true);
        wsHandler.broadcastStatus(currentStatus);

        scheduler.schedule(() -> {
            // Simulate token refresh success
            List<String> refreshedTokens = List.of(
                "OPTION_CHAIN_1", "WEBSOCKET_1", "OPTION_CHAIN_2", "WEBSOCKET_2"
            );
            loginSuccess(refreshedTokens);
        }, 3, TimeUnit.SECONDS); // 3s reconnect cooldown
    }
}


✅ Features implemented:

Sends per-second remainingSeconds to frontend.

Marks expired tokens and automatically attempts refresh.

Broadcasts RECONNECTING state with a short cooldown.

Full reactive update, no polling needed.

2. Frontend – React WebSocket + Countdown

We add Vega-style countdown timer and auto-reconnect UI logic.

2.1 AuthStatus Hook with Reconnect
import { useEffect, useState } from "react";

export default function useAuthStatus() {
    const [status, setStatus] = useState<any>(null);
    const [ws, setWs] = useState<WebSocket | null>(null);

    useEffect(() => {
        let socket: WebSocket;

        const connect = () => {
            socket = new WebSocket("ws://localhost:5173/ws/auth/status");

            socket.onopen = () => console.log("WS connected");
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                setStatus(data);
            };
            socket.onclose = () => {
                console.log("WS closed, reconnecting...");
                setTimeout(connect, 2000); // Auto reconnect after 2s
            };

            setWs(socket);
        };

        connect();

        return () => socket.close();
    }, []);

    return status;
}

2.2 Login Component with Countdown
import React, { useState, useEffect } from "react";
import useAuthStatus from "./useAuthStatus";

export default function Login() {
    const [username, setUsername] = useState("");
    const [password, setPassword] = useState("");
    const status = useAuthStatus();
    const [countdown, setCountdown] = useState(0);

    useEffect(() => {
        if (status) setCountdown(status.remainingSeconds);
    }, [status]);

    const handleLogin = async () => {
        await fetch("/api/auth/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username, password })
        });
    };

    return (
        <div style={{ padding: 20 }}>
            <input placeholder="Username" value={username} onChange={e => setUsername(e.target.value)} />
            <input placeholder="Password" type="password" value={password} onChange={e => setPassword(e.target.value)} />
            <button onClick={handleLogin}>Login</button>

            {status && (
                <div style={{ marginTop: 20 }}>
                    <p>State: {status.state}</p>
                    <p>Authenticated: {status.authenticated ? "Yes" : "No"}</p>
                    <p>Primary Ready: {status.primaryReady ? "Yes" : "No"}</p>
                    <p>Tokens: {status.generatedTokens}/{status.requiredTokens}</p>
                    {status.authenticated && (
                        <p>Token expires in: {countdown}s</p>
                    )}
                    {status.state === "RECONNECTING" && <p>Reconnecting...</p>}
                    {status.state === "EXPIRED" && <p>Token expired, refreshing...</p>}
                </div>
            )}
        </div>
    );
}

3. Behavior Overview
Event	Backend Action	Frontend Action
Login	Validate → broadcast AUTH_CONFIRMED	Show authenticated UI
Token ticking	Broadcast remainingSeconds every second	Countdown timer updates in UI
Token expiry	Set EXPIRED → attempt autoRefreshTokens()	Show expired / reconnecting UI
Refresh success	Broadcast new AUTH_CONFIRMED	Reset countdown, update UI
WebSocket disconnect	Auto-reconnect after 2s	Attempt to reconnect automatically

✅ Advantages for Vega HFT Dashboard

Single WebSocket per client, no polling.

Per-second countdown updates like Bloomberg/Vega.

Automatic reconnect and token refresh.

UI immediately reacts to token state changes.

Scales well for multiple users and high-frequency dashboard.