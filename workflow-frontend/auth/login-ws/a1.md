Let’s design a full WebSocket-based auth workflow for your Vega frontend/backend, replacing polling. I’ll include login flow, token management, expiry detection, and frontend updates. This is production-grade, reactive, and HFT-friendly.

1. Backend – Spring Boot Setup
Dependencies (Maven)
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>

1.1 WebSocket Config
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(authStatusHandler(), "/ws/auth/status")
                .setAllowedOrigins("*");
    }

    @Bean
    public AuthStatusWebSocketHandler authStatusHandler() {
        return new AuthStatusWebSocketHandler();
    }
}

1.2 WebSocket Handler
@Component
public class AuthStatusWebSocketHandler extends TextWebSocketHandler {

    private final List<WebSocketSession> sessions = new CopyOnWriteArrayList<>();
    private final ObjectMapper mapper = new ObjectMapper();

    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        sessions.add(session);
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        sessions.remove(session);
    }

    public void broadcastStatus(AuthStatus status) {
        String payload;
        try {
            payload = mapper.writeValueAsString(status);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return;
        }

        sessions.forEach(session -> {
            if (session.isOpen()) {
                try {
                    session.sendMessage(new TextMessage(payload));
                } catch (IOException ignored) {}
            }
        });
    }
}

1.3 AuthStatus DTO
@Data
@AllArgsConstructor
@NoArgsConstructor
public class AuthStatus {
    private String state;               // e.g., AUTH_CONFIRMED, EXPIRED
    private boolean authenticated;
    private boolean primaryReady;
    private boolean fullyReady;
    private int generatedTokens;
    private int requiredTokens;
    private List<String> validTokens;
    private boolean inProgress;
    private boolean cooldownActive;
    private int remainingSeconds;
}

1.4 Auth Service
@Service
public class AuthService {

    private final AuthStatusWebSocketHandler wsHandler;
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    private AuthStatus currentStatus;

    public AuthService(AuthStatusWebSocketHandler wsHandler) {
        this.wsHandler = wsHandler;
        this.currentStatus = new AuthStatus(
                "UNAUTHENTICATED",
                false, false, false,
                0, 0,
                List.of(),
                false,
                false,
                0
        );
        startTokenExpiryChecker();
    }

    public void loginSuccess(List<String> validTokens) {
        currentStatus.setState("AUTH_CONFIRMED");
        currentStatus.setAuthenticated(true);
        currentStatus.setFullyReady(true);
        currentStatus.setPrimaryReady(true);
        currentStatus.setValidTokens(validTokens);
        currentStatus.setGeneratedTokens(validTokens.size());
        currentStatus.setRequiredTokens(validTokens.size());
        wsHandler.broadcastStatus(currentStatus);
    }

    private void startTokenExpiryChecker() {
        scheduler.scheduleAtFixedRate(() -> {
            if (currentStatus.isAuthenticated()) {
                boolean expired = checkTokenExpiry();
                if (expired) {
                    currentStatus.setState("EXPIRED");
                    currentStatus.setAuthenticated(false);
                    currentStatus.setFullyReady(false);
                    currentStatus.setPrimaryReady(false);
                    wsHandler.broadcastStatus(currentStatus);
                }
            }
        }, 0, 5, TimeUnit.SECONDS);
    }

    private boolean checkTokenExpiry() {
        // Replace with real token expiry logic
        return false;
    }
}

1.5 REST Login Controller (Initial Login)
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        // validate credentials
        boolean success = true; // replace with real validation
        if (success) {
            authService.loginSuccess(List.of(
                "OPTION_CHAIN_1", "WEBSOCKET_1", "OPTION_CHAIN_2", "WEBSOCKET_2", "WEBSOCKET_3", "PRIMARY"
            ));
            return ResponseEntity.ok(Map.of("status", "success"));
        }
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("status", "failure"));
    }
}

@Data
class LoginRequest {
    private String username;
    private String password;
}

2. Frontend – React WebSocket Integration
2.1 Hook to Handle AuthStatus
import { useEffect, useState } from "react";

export default function useAuthStatus() {
    const [status, setStatus] = useState<any>(null);

    useEffect(() => {
        const ws = new WebSocket("ws://localhost:5173/ws/auth/status");

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            setStatus(data);
        };

        ws.onclose = () => console.log("Auth WS closed");

        return () => ws.close();
    }, []);

    return status;
}

2.2 Login Component
import React, { useState } from "react";
import useAuthStatus from "./useAuthStatus";

export default function Login() {
    const [username, setUsername] = useState("");
    const [password, setPassword] = useState("");
    const status = useAuthStatus();

    const handleLogin = async () => {
        const res = await fetch("/api/auth/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username, password })
        });
        if (res.ok) console.log("Login submitted");
    };

    return (
        <div>
            <input placeholder="Username" value={username} onChange={e => setUsername(e.target.value)} />
            <input placeholder="Password" type="password" value={password} onChange={e => setPassword(e.target.value)} />
            <button onClick={handleLogin}>Login</button>

            {status && (
                <div>
                    <p>State: {status.state}</p>
                    <p>Authenticated: {status.authenticated ? "Yes" : "No"}</p>
                    <p>Primary Ready: {status.primaryReady ? "Yes" : "No"}</p>
                    <p>Tokens: {status.generatedTokens}/{status.requiredTokens}</p>
                </div>
            )}
        </div>
    );
}

2.3 Behavior

User hits Login → REST call.

Backend validates → pushes AuthStatus via WebSocket.

Frontend updates reactively.

Token expiry / invalidation is pushed by backend — no polling required.

Connection closes automatically on component unmount.

✅ Key Advantages

No repeated polling every second.

Single WS connection per client.

Immediate frontend updates on login / expiry / token refresh.

Scales better for multi-user HFT dashboards.

Easy to extend for replay sessions or market data token tracking.