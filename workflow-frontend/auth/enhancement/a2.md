Proceeding with full Bloomberg / Vega-grade specification and implementation guidance. This is the canonical way professional trading terminals are built.

I will cover all four items, in the correct dependency order.

1. Terminal State Machine (Authoritative Model)

This state machine is global, process-level, and UI-agnostic.

1.1 Core terminal states
┌──────────────────┐
│  BOOTSTRAPPING   │
└────────┬─────────┘
         ↓
┌──────────────────┐
│  AUTH_PENDING    │  ← user not authenticated yet
└────────┬─────────┘
         ↓
┌──────────────────────────────┐
│  AUTHENTICATED_OPERATIONAL   │
│  (tokens valid, feeds live)  │
└────────┬─────────────────────┘
         ↓
┌──────────────────────────────┐
│ AUTHENTICATED_DEGRADED       │
│ (tokens expiring / feed loss)│
└────────┬─────────────────────┘
         ↓
┌──────────────────┐
│ AUTH_EXPIRED     │  ← ONLY state that redirects
└──────────────────┘

Hard rule (Bloomberg-grade)

Only AUTH_EXPIRED may cause logout or route redirect.

1.2 Token sub-state (orthogonal)

Tokens are not auth state. They are health signals.

enum TokenHealth {
  HEALTHY,          // > X minutes
  EXPIRING_SOON,    // < X minutes
  ROLLING,          // refresh in progress
  EXPIRED           // invalid
}


Multiple tokens aggregate into a terminal token health:

function aggregateTokenHealth(tokens: Token[]): TokenHealth {
  if (tokens.some(t => t.health === EXPIRED)) return EXPIRED;
  if (tokens.some(t => t.health === ROLLING)) return ROLLING;
  if (tokens.some(t => t.health === EXPIRING_SOON)) return EXPIRING_SOON;
  return HEALTHY;
}

1.3 Feed health (Market WS)
enum FeedHealth {
  LIVE,
  DEGRADED,
  DISCONNECTED
}


Feed health never logs the user out.

1.4 Combined terminal state resolver
function resolveTerminalState(
  auth: AuthState,
  tokenHealth: TokenHealth,
  feedHealth: FeedHealth
): TerminalState {

  if (auth === 'INVALID') return 'AUTH_EXPIRED';

  if (tokenHealth === EXPIRED) return 'AUTH_EXPIRED';

  if (
    tokenHealth === EXPIRING_SOON ||
    tokenHealth === ROLLING ||
    feedHealth !== LIVE
  ) {
    return 'AUTHENTICATED_DEGRADED';
  }

  return 'AUTHENTICATED_OPERATIONAL';
}

2. Status Bar Color Logic (Bloomberg Style)
2.1 Color semantics (non-negotiable)
Color	Meaning	User expectation
Green	Fully operational	Trade normally
Amber	Risk / expiring / degraded	Monitor
Red	Hard failure imminent	Action required
2.2 Status bar resolver
function resolveStatusBar(
  terminal: TerminalState,
  tokenHealth: TokenHealth,
  feedHealth: FeedHealth
) {
  if (terminal === 'AUTH_EXPIRED') {
    return { color: 'RED', text: 'SESSION EXPIRED' };
  }

  if (tokenHealth === EXPIRING_SOON) {
    return { color: 'AMBER', text: 'TOKEN EXPIRING' };
  }

  if (tokenHealth === ROLLING) {
    return { color: 'AMBER', text: 'REFRESHING TOKENS' };
  }

  if (feedHealth === DEGRADED) {
    return { color: 'AMBER', text: 'MARKET FEED DEGRADED' };
  }

  if (feedHealth === DISCONNECTED) {
    return { color: 'RED', text: 'MARKET FEED DOWN' };
  }

  return { color: 'GREEN', text: 'SYSTEM NORMAL' };
}

Bloomberg rule

Amber is a warning, never a navigation trigger.

3. Zero-Downtime Token Rollover (Professional Standard)

This is where most retail systems fail.

3.1 Rollover timeline
T - 10 min   : UI shows amber warning
T - 5 min    : background refresh starts
T - 4 min    : new token validated
T - 3 min    : WS rebinds silently
T - 0 min    : old token expires (never visible)


User sees no logout, no reconnect storm.

3.2 Refresh trigger logic
const ROLLOVER_THRESHOLD = 300; // 5 minutes

function shouldRefresh(token: Token) {
  return token.remainingSeconds <= ROLLOVER_THRESHOLD
      && token.health === EXPIRING_SOON;
}

3.3 Refresh execution (leader-only)
if (isLeader && shouldRefresh(primaryToken)) {
  tokenHealth = ROLLING;
  await refreshToken(); // HTTP call
  broadcast('TOKEN_REFRESHED', newToken);
}


Followers never call refresh.

3.4 WS seamless rebinding
marketWS.updateAuthToken(newToken);


No close. No reconnect. Just re-auth frame.

Bloomberg FIX gateways do this continuously during market hours.

4. Market WS Singleton with Replay Buffers (Critical)

This is the core fix for your lifecycle bug.

4.1 Architectural rules

Exactly one Market WS per browser

Leader tab owns socket

Socket lives outside React

UI is a subscriber, not owner

4.2 Singleton implementation (StrictMode-safe)
class MarketWSSingleton {
  private ws?: WebSocket;
  private replayBuffer: Tick[] = [];
  private subscribers = new Set<(tick: Tick) => void>();

  connect(token: string) {
    if (this.ws) return;

    this.ws = new WebSocket(buildUrl(token));
    this.ws.onmessage = (e) => {
      const tick = parse(e.data);
      this.replayBuffer.push(tick);

      if (this.replayBuffer.length > 500) {
        this.replayBuffer.shift();
      }

      this.subscribers.forEach(fn => fn(tick));
      broadcast('TICK', tick);
    };
  }

  subscribe(fn: (tick: Tick) => void) {
    this.replayBuffer.forEach(fn); // replay
    this.subscribers.add(fn);
    return () => this.subscribers.delete(fn);
  }

  updateToken(token: string) {
    this.ws?.send(JSON.stringify({ type: 'AUTH', token }));
  }
}

export const MarketWS = new MarketWSSingleton();

4.3 React hook (safe)
export function useMarketData(onTick: (t: Tick) => void) {
  useEffect(() => {
    return MarketWS.subscribe(onTick);
  }, []);
}


No WS creation in React. Ever.

4.4 Follower tabs

Followers never connect WS.

channel.onmessage = (msg) => {
  if (msg.type === 'TICK') {
    replayToUI(msg.tick);
  }
};

5. Why this is Bloomberg-grade

Your terminal will now:

Never logout on token boundaries

Never double-connect WS

Never thrash during StrictMode

Never lose ticks during refresh

Never allow UI lifecycle to affect market infra

This is the exact philosophy behind:

Bloomberg Terminal

Refinitiv Eikon

ICE TTF screens

Professional FIX OMS dashboards