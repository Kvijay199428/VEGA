Below is a production-grade, end-to-end implementation guide that completes all four items you requested and aligns your system with institutional-terminal behavior.

I am treating this as final architecture, not a patch.

1. TOKEN HYDRATION ON APPLICATION STARTUP (BACKEND)
Objective

When the backend starts:

Read all persisted tokens

Validate them using validity_at

Build an in-memory auth snapshot

Avoid Selenium unless explicitly required

This eliminates:

False ‚Äú0 / 6‚Äù states

Unnecessary login flows

Selenium auto-crashes

1.1 Startup Hydration Flow
Execution timing

Use ApplicationReadyEvent, not @PostConstruct.

Class
com.vegatrader.upstox.auth.lifecycle.TokenHydrationService

Implementation
@Component
@RequiredArgsConstructor
@Slf4j
public class TokenHydrationService {

    private final UpstoxTokenRepository tokenRepository;
    private final AuthSessionState authSessionState;

    @EventListener(ApplicationReadyEvent.class)
    public void hydrateTokens() {
        Instant now = Instant.now();

        log.info("[AUTH-HYDRATION] Starting token hydration at {}", now);

        List<UpstoxToken> validTokens =
                tokenRepository.findActiveAndValid(now);

        validTokens.forEach(token -> {
            authSessionState.registerValidToken(token.getApiName());
            log.info("[AUTH-HYDRATION] Token hydrated: {} (valid till {})",
                    token.getApiName(), token.getValidityAt());
        });

        authSessionState.evaluateReadiness();

        log.info("[AUTH-HYDRATION] Hydration complete | valid={} missing={}",
                authSessionState.getValidApis().size(),
                authSessionState.getMissingApis().size());
    }
}

1.2 Repository Query (MANDATORY)
@Query("""
    SELECT t FROM UpstoxToken t
    WHERE t.isActive = true
      AND t.validityAt > :now
""")
List<UpstoxToken> findActiveAndValid(@Param("now") Instant now);

Result

‚úî Backend knows all tokens immediately
‚úî /api/auth/session is correct on first request
‚úî Selenium never runs if PRIMARY exists

2. SESSION-AWARE AUTO-REDIRECT (LOGIN BYPASS)
Requirement

If user manually opens:

http://localhost:5173/login


AND session is valid ‚Üí auto-redirect to dashboard

2.1 Backend Contract (Already Correct)

You already return:

{
  "primaryReady": true,
  "fullyReady": true,
  "canProceed": true,
  "status": "SUCCESS"
}


We will enforce behavior on frontend.

2.2 Frontend Route Guard (React)
File
src/routes/LoginGuard.tsx

export async function loginGuard() {
  const res = await fetch("/api/auth/session", { credentials: "include" });
  const session = await res.json();

  if (session.fullyReady && session.primaryReady) {
    return redirect("/dashboard");
  }

  return null;
}

2.3 Route Configuration
<Route
  path="/login"
  element={<LoginPage />}
  loader={loginGuard}
/>

Result

‚úî Login page is never shown when session is valid
‚úî Manual URL entry behaves correctly
‚úî Matches Bloomberg / OMS behavior

3. SSE-DRIVEN TOKEN GENERATION PROGRESS
Objective

Real-time feedback

No polling

Clear operator visibility

3.1 SSE Endpoint
Backend Controller
GET /api/auth/progress

@GetMapping(value = "/api/auth/progress", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<AuthProgressEvent> streamProgress() {
    return authProgressPublisher.getStream();
}

3.2 Progress Event Model
@Data
@AllArgsConstructor
public class AuthProgressEvent {
    private String api;
    private String status; // STARTED, SUCCESS, FAILED
    private int completed;
    private int total;
    private Instant timestamp;
}

3.3 Publish Events During Selenium Flow
progressPublisher.emit(
    new AuthProgressEvent(
        apiName,
        "SUCCESS",
        completedCount,
        totalApis,
        Instant.now()
    )
);

3.4 Frontend Subscription
useEffect(() => {
  const es = new EventSource("/api/auth/progress");

  es.onmessage = e => {
    const event = JSON.parse(e.data);
    updateProgressUI(event);
  };

  return () => es.close();
}, []);

Result

‚úî Operator sees live token generation
‚úî No ‚Äústuck‚Äù login states
‚úî Audit-friendly

4. TOKEN EXPIRY TIMELINE (TERMINAL-GRADE)
Objective

Show:

Remaining validity

Expiry order

Risk exposure

4.1 Backend API
GET /api/auth/tokens/timeline

Response
[
  {
    "api": "PRIMARY",
    "validUntil": "2026-01-01T03:30:00",
    "remainingSeconds": 86390,
    "status": "HEALTHY"
  }
]

4.2 Backend Calculation
Duration remaining = Duration.between(Instant.now(), token.getValidityAt());

TokenHealth status =
    remaining.toMinutes() < 10 ? CRITICAL :
    remaining.toHours() < 1 ? WARNING :
    HEALTHY;

4.3 Frontend UI (Bloomberg-Style)
API	Remaining	Status
PRIMARY	23h 59m	üü¢
WS-1	22h 10m	üü¢
OPTION-2	8m	üî¥
Optional: Timeline Bar

Horizontal bar

Color gradient

Tooltip on hover

5. FINAL LOGIN FLOW (AUTHORITATIVE)
On App Start

Hydrate tokens from DB

Evaluate validity using validity_at

On /login

Session valid ‚Üí redirect

Session invalid ‚Üí show login UI

On PRIMARY valid

Show:

PROCEED WITH PRIMARY

GENERATE REMAINING TOKENS

On logout

Clear session state

Redirect to login

6. WHY THIS IS NOW CORRECT (AUDIT JUSTIFICATION)

Deterministic startup behavior

No UI/DB mismatch

No Selenium side effects

Stateless frontend

Stateful backend authority

Aligns with OMS / EMS / Bloomberg terminal patterns