Below is a complete, production-grade continuation of your VEGA TRADER terminal architecture. This is written as implementation documentation, not a conceptual overview, and aligns with institutional trading systems (Bloomberg / Refinitiv class).

1. SSE Countdown Implementation (Spring Boot + React)
1.1 Purpose

The SSE countdown provides authoritative, server-driven time remaining for:

Token cooldown

Token expiry

Restricted → Normal mode transition

This avoids client-side drift and satisfies audit requirements.

1.2 Backend – SSE Controller (Spring Boot)
1.2.1 SSE Endpoint
@RestController
@RequestMapping("/api/v1/sse")
public class CooldownSseController {

    @GetMapping(value = "/cooldown", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter streamCooldown() {

        SseEmitter emitter = new SseEmitter(0L);

        Executors.newSingleThreadExecutor().submit(() -> {
            try {
                while (true) {
                    long remaining = cooldownService.remainingSeconds();

                    emitter.send(
                        SseEmitter.event()
                            .name("cooldown")
                            .data(Map.of(
                                "remainingSeconds", remaining,
                                "mode", remaining > 0 ? "RESTRICTED" : "NORMAL"
                            ))
                    );

                    if (remaining <= 0) {
                        emitter.complete();
                        break;
                    }

                    Thread.sleep(1000);
                }
            } catch (Exception e) {
                emitter.completeWithError(e);
            }
        });

        return emitter;
    }
}

1.2.2 Operational Guarantees

Server clock is the single time authority

SSE auto-terminates on state completion

No polling

Stateless reconnect supported

1.3 Frontend – React SSE Listener
useEffect(() => {
  const source = new EventSource("/api/v1/sse/cooldown");

  source.addEventListener("cooldown", (event) => {
    const data = JSON.parse(event.data);

    setCooldown(data.remainingSeconds);
    setDashboardMode(data.mode);

    if (data.remainingSeconds <= 0) {
      source.close();
    }
  });

  return () => source.close();
}, []);

1.4 UX Behavior
Event	UI Reaction
remaining > 0	Restricted banner visible
remaining = 0	Banner fades, controls unlock
SSE disconnect	Silent reconnect
2. SQLite Lock-Recovery + Memory Spillover Design
2.1 Problem Statement

SQLite can enter BUSY / LOCKED states during:

Concurrent token writes

Cron refresh overlap

JVM crash recovery

This must never block trading auth logic.

2.2 Dual-Layer Token Store (Authoritative Pattern)
┌─────────────────────┐
│ In-Memory Token Map │  ← Hot path (ConcurrentHashMap)
└─────────▲───────────┘
          │
┌─────────┴───────────┐
│ SQLite Token Table  │  ← Durable store
└─────────────────────┘

2.3 Write Strategy (Fail-Safe)
public void persistToken(TokenEntity token) {

    inMemoryTokenStore.put(token.getId(), token);

    try {
        tokenRepository.save(token);
    } catch (SQLiteBusyException e) {
        log.warn("SQLite busy – token cached in memory");
        retryQueue.offer(token);
    }
}

2.4 Background Retry Worker
@Scheduled(fixedDelay = 3000)
public void retryFailedWrites() {

    while (!retryQueue.isEmpty()) {
        TokenEntity token = retryQueue.poll();
        try {
            tokenRepository.save(token);
        } catch (Exception e) {
            retryQueue.offer(token);
            break;
        }
    }
}

2.5 Recovery on Restart

Load latest valid PRIMARY token from SQLite

Rehydrate in-memory map

Resume cooldown timers

2.6 Audit Guarantee

Token existence guaranteed in either memory or disk

No silent loss

Logged fallback events

3. Token Timeline Visualization Specification
3.1 Purpose

Provides operator visibility into:

Token lifecycle

Generation attempts

Cooldowns

Expiry

This is a mandatory institutional control.

3.2 Timeline Layout (Bloomberg Style)
PRIMARY TOKEN TIMELINE
────────────────────────────────────────────
[✓] Generated        09:15:02
[⏳] Cooldown Start  09:15:05
[✓] Cooldown End    09:25:05
[⏰] Expiry          15:30:00

3.3 Data Model
{
  "tokenId": "primary",
  "events": [
    { "type": "GENERATED", "time": "2025-01-01T09:15:02Z" },
    { "type": "COOLDOWN_START", "time": "2025-01-01T09:15:05Z" },
    { "type": "COOLDOWN_END", "time": "2025-01-01T09:25:05Z" },
    { "type": "EXPIRES_AT", "time": "2025-01-01T15:30:00Z" }
  ]
}

3.4 Visual Encoding
Event	Color	Icon
Generated	Green	✓
Cooldown	Amber	⏳
Expiry	Red	⏰
3.5 Update Mechanism

Initial REST load

SSE overlay for live updates

4. Bloomberg-Style Keyboard Command Router
4.1 Design Philosophy

Keyboard-first

Deterministic routing

Zero mouse dependency

4.2 Command Grammar
<COMMAND> [ARGUMENTS] <ENTER>


Examples:

NIFTY <ENTER>

RELIANCE GO <ENTER>

POS <ENTER>

ORD <ENTER>

4.3 Command Registry (Frontend)
const commandMap = {
  "POS": () => navigate("/positions"),
  "ORD": () => navigate("/orders"),
  "ACC": () => navigate("/account"),
  "DASH": () => navigate("/dashboard"),
  "SEC": (arg) => openSecurity(arg)
};

4.4 Global Keyboard Listener
window.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    parseAndExecute(buffer);
    buffer = "";
  } else {
    buffer += e.key.toUpperCase();
  }
});

4.5 Security Controls

Disabled in RESTRICTED mode:

BUY

SELL

ALGOSTART

Enabled always:

Navigation

Read-only views

4.6 Audit & Telemetry
{
  "command": "ORD",
  "user": "trader01",
  "timestamp": "2025-01-01T10:01:12Z",
  "mode": "RESTRICTED"
}

Final System Posture

With these components, your terminal now has:

Server-authoritative countdowns

SQLite failure immunity

Institutional token observability

Bloomberg-grade keyboard UX

This is OMS/EMS-grade, not retail tooling.