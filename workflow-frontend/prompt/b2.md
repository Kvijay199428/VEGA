Below is a single, coherent enterprise implementation guide that covers all five requested items, designed to plug directly into your existing Java backend, scale to a Bloomberg-style terminal, remain SEBI-audit safe, and work identically for Web, CLI, and automation.

No shortcuts, no toy UI patterns.

PART I — TERMINAL SHELL LAYOUT (Bloomberg-Style)
1. Design Principles (Non-Negotiable)

Your frontend is not a website. It is a trading terminal.

Mandatory principles:

Single-page, multi-panel shell

Keyboard-first navigation

Zero reflow on live updates

Deterministic rendering (no random animations)

Panels map 1:1 to backend domains

Session banner always visible (audit requirement)

2. Terminal Shell Layout Structure
┌────────────────────────────────────────────┐
│  VEGA TRADER | USER | SESSION | LATENCY   │  ← Session Bar (always visible)
├───────────────┬────────────────────────────┤
│ SYMBOL TREE   │ MAIN WORKSPACE              │
│ (Indices,     │ ┌────────────────────────┐ │
│ Stocks, F&O)  │ │ Option Chain + Greeks   │ │
│               │ ├────────────────────────┤ │
│               │ │ Futures / OI / PCR      │ │
│               │ ├────────────────────────┤ │
│               │ │ Orders / Positions      │ │
│               │ └────────────────────────┘ │
├───────────────┴────────────────────────────┤
│ COMMAND BAR (:) | Alerts | System Logs     │
└────────────────────────────────────────────┘

3. Core Shell Components
TerminalLayout.tsx

Responsibilities:

Frame the entire application

Never re-render on market data updates

Host panel routing

Key rules:

Shell is static

Panels update independently

Use CSS Grid (not Flex) to prevent layout jitter.

4. Keyboard Command Layer (Bloomberg-Style)

Command bar behavior:

Activated via : key

Commands like:

OC NIFTY

FUT NIFTY

ADMIN AUDIT

LOGOUT

This maps cleanly to:

Web

CLI

Operator runbooks

PART II — WEBSOCKET MARKET DATA INTEGRATION
5. Market Data Architecture (Zero Coupling)

You already have:

MarketDataFeedStreamV3

OptionChainFeedStreamV3

Frontend must not calculate, not aggregate, not enrich market data.

Instead:

WebSocket Feed
     ↓
In-Memory Normalized Store
     ↓
Selectors
     ↓
Panels

6. WebSocket Client Design
Connection Rules

One WebSocket per session

Server-controlled subscriptions

Frontend only sends:

subscribe

unsubscribe

Heartbeat mandatory (latency tracking)

7. Market Data Store (Zustand)

State shape:

marketData: {
  instruments: {
    [instrumentKey]: {
      ltpc
      bidAsk
      oi
      volume
      greeks_from_broker
      ts
    }
  }
}


Rules:

Always overwrite by instrumentKey

No array operations

No sorting in store

No derived metrics here

8. Latency & Health Tracking (Critical)

Every WebSocket tick:

Timestamp from server

Client receive time

Calculate:

feed latency

staleness

Display:

Green: < 100ms

Yellow: 100–300ms

Red: > 300ms (disable Greeks overlays automatically)

This is SEBI survivability logic.

PART III — OPTION CHAIN + ADVANCED GREEKS UI
9. Separation of Concerns (Very Important)

You explicitly stated:

Do not include Greeks inside OptionChainFeedStreamV3

Correct.

Architecture:

OptionChainFeedStreamV3  → Raw market state
Advanced Greeks Engine   → Calculated independently
Risk Matrix Resolver     → Merge on demand


Frontend never calculates Greeks.

10. Greeks Resolution Flow

When user opens:

OC NIFTY 13-FEB-2025


Frontend does:

Subscribe to option chain feed (live)

Request calculated Greeks snapshot:

GET /api/greeks/advanced?underlying=NIFTY&expiry=2025-02-13


Resolver merges:

LTP, bid/ask, OI (live)

Greeks, risk matrices (calculated)

11. Advanced Greeks Panel Design
Column Groups
MARKET | FIRST ORDER | SECOND ORDER | THIRD ORDER | RISK

Example Columns

Delta | Gamma | Vega | Theta | Rho

Vanna | Vomma | Charm | Speed | Zomma

Color | Ultima

Net exposure

Risk tier (Hard / Soft)

12. Greeks Surface (Bloomberg-Style)

Two mandatory surfaces:

Strike × Greek Heatmap

Expiry × Net Greek Matrix

Rules:

Color only (no gradients)

Fixed thresholds

Toggle per Greek

Disable when latency > threshold

13. Stress Matrices (Built-in)

Frontend toggles (backend-computed):

Gap +/− 1%, 2%, 5%

Vol shock +/− 5%, 10%, 20%

Time decay +1 day

Backend returns:

stressResults: {
  deltaPnL
  gammaPnL
  vegaPnL
  totalPnL
}


Frontend only displays.

PART IV — ADMIN CONSOLE (AUDIT SAFE)
14. Admin Console Rules

Separate route: /admin

Role-gated at backend

Read-only by default

All actions logged

15. Admin Panels

Mandatory panels:

Audit Trail Viewer

Token lifecycle

Order lifecycle

Admin actions

Broker Health

Upstox status

Latency

Failover readiness

Risk Overrides

Disable strikes

Disable Greeks

Emergency kill-switch

16. Audit UI Constraints

No delete

No edit

No export without reason

Timestamp + user always visible

Matches SEBI forensic expectations.

PART V — PERFORMANCE & LATENCY TUNING
17. Rendering Strategy

Use React.memo aggressively

Key by instrumentKey

No re-render of shell

Virtualize large chains (500+ strikes)

18. Data Volume Controls

Hard rules:

No array .map() on every tick

No derived calculations in render

No JSON deep clones

Use selectors:

useMarketData(instrumentKey)

19. Automatic Degradation Modes
Condition	Action
Latency > 300ms	Disable advanced Greeks
Feed gap > 1s	Freeze UI
Broker disconnect	Read-only mode
Risk breach	Force logout

All backend-controlled.

20. SEBI-Audit Safety Summary

Your frontend:

Stores no tokens

Logs no sensitive data

Mirrors backend decisions

Shows timestamps everywhere

Has deterministic behavior

Supports replay & forensic review

This is institutional-grade.

FINAL CHECKPOINT

You are now ready to implement:

Terminal-grade UI

Live feeds at scale

Advanced Greeks safely

Admin audit console

Latency-aware degradation