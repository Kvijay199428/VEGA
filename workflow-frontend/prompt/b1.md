This package.json is enterprise-correct and already aligned with what you want to build. I will now give you a production-grade frontend implementation guide starting from User Login, fully compliant with:

Your Java/Spring backend

SEBI audit expectations

Bloomberg-style terminal UX

Web + CLI + automation parity

No OAuth anti-patterns

I will not give toy React examples. This is a system design + implementation guide.

1. Frontend Architecture (Authoritative)
Core principles (must not violate)

Backend is the source of truth

Frontend is stateless across reloads

No tokens in LocalStorage

Session lifecycle is auditable

Same auth flow works for Web, CLI, curl

Directory Structure (recommended)
src/
├── app/
│   ├── App.tsx
│   ├── Router.tsx
│   └── Bootstrap.tsx        # Session bootstrap & health check
│
├── auth/
│   ├── LoginPage.tsx
│   ├── LoginForm.tsx
│   ├── AuthService.ts
│   ├── authStore.ts         # Zustand store
│   └── types.ts
│
├── api/
│   ├── httpClient.ts        # Axios hardened client
│   ├── endpoints.ts
│   └── errorMapper.ts
│
├── security/
│   ├── csrf.ts
│   ├── headers.ts
│   └── auditContext.ts
│
├── ui/
│   ├── TerminalLayout.tsx
│   └── components/
│
├── styles/
│   └── tailwind.css
│
└── main.tsx


This mirrors your Java service boundaries (auth, settings, orders, market-data).

2. Authentication Model (SEBI-Safe)
What we explicitly DO NOT do

❌ OAuth implicit flow

❌ Store access tokens in browser storage

❌ Redirect-based auth

❌ Frontend-controlled refresh tokens

What we DO

Backend issues HttpOnly, Secure cookies

Frontend sends credential payload

Backend handles:

token lifecycle

broker auth

audit logging

Frontend only tracks session state

This matches:

SEBI cyber security circulars

Institutional OMS patterns

Bloomberg Terminal behavior

3. API Client (Hardened Axios)
src/api/httpClient.ts
import axios from "axios";

export const httpClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  withCredentials: true, // REQUIRED for HttpOnly cookies
  timeout: 10_000,
  headers: {
    "Content-Type": "application/json",
    "X-Client-Type": "WEB_TERMINAL",
  },
});

httpClient.interceptors.response.use(
  (res) => res,
  (err) => {
    if (err.response?.status === 401) {
      window.dispatchEvent(new Event("session-expired"));
    }
    return Promise.reject(err);
  }
);


Why this matters

Same client works for:

Web

CLI (curl -b cookie.txt)

Automation

4. Auth Contracts (Frontend ↔ Backend)
Request
POST /api/auth/login

{
  "clientCode": "ABC123",
  "password": "********",
  "totp": "123456",
  "deviceId": "web-terminal"
}

Response (NO TOKEN BODY)
{
  "status": "SUCCESS",
  "user": {
    "id": "U123",
    "role": "USER",
    "displayName": "Vijay Sharma"
  }
}


Session cookies are set by backend.

5. Auth State Store (Zustand)
src/auth/authStore.ts
import { create } from "zustand";

interface AuthState {
  authenticated: boolean;
  user?: {
    id: string;
    role: "USER" | "ADMIN";
    displayName: string;
  };
  setAuthenticated: (user: AuthState["user"]) => void;
  logout: () => void;
}

export const useAuthStore = create<AuthState>((set) => ({
  authenticated: false,

  setAuthenticated: (user) =>
    set({
      authenticated: true,
      user,
    }),

  logout: () =>
    set({
      authenticated: false,
      user: undefined,
    }),
}));


This store is:

In-memory only

Reset on refresh

Audit-safe

6. Auth Service
src/auth/AuthService.ts
import { httpClient } from "@/api/httpClient";

export const AuthService = {
  async login(payload: {
    clientCode: string;
    password: string;
    totp: string;
  }) {
    const res = await httpClient.post("/api/auth/login", payload);
    return res.data;
  },

  async bootstrap() {
    const res = await httpClient.get("/api/auth/session");
    return res.data;
  },

  async logout() {
    await httpClient.post("/api/auth/logout");
  },
};

7. Login Page (Production-grade)
src/auth/LoginPage.tsx
import { useForm } from "react-hook-form";
import { AuthService } from "./AuthService";
import { useAuthStore } from "./authStore";

export function LoginPage() {
  const { register, handleSubmit } = useForm();
  const setAuthenticated = useAuthStore((s) => s.setAuthenticated);

  const onSubmit = async (data: any) => {
    const res = await AuthService.login(data);
    setAuthenticated(res.user);
  };

  return (
    <div className="h-screen flex items-center justify-center bg-black text-white">
      <form
        onSubmit={handleSubmit(onSubmit)}
        className="w-96 space-y-4 border border-gray-700 p-6"
      >
        <h1 className="text-xl font-bold">VEGA TRADER</h1>

        <input {...register("clientCode")} placeholder="Client Code" />
        <input {...register("password")} type="password" placeholder="Password" />
        <input {...register("totp")} placeholder="TOTP" />

        <button className="w-full bg-green-600 py-2">
          Login
        </button>
      </form>
    </div>
  );
}


This UI is intentionally:

Dense

Keyboard-friendly

Terminal-like

No animations (audit friendly)

8. Session Bootstrap (Critical)
src/app/Bootstrap.tsx
import { useEffect } from "react";
import { AuthService } from "@/auth/AuthService";
import { useAuthStore } from "@/auth/authStore";

export function Bootstrap({ children }: { children: React.ReactNode }) {
  const setAuthenticated = useAuthStore((s) => s.setAuthenticated);

  useEffect(() => {
    AuthService.bootstrap()
      .then((res) => setAuthenticated(res.user))
      .catch(() => {});
  }, []);

  return <>{children}</>;
}

9. Router Guard
import { Navigate } from "react-router-dom";
import { useAuthStore } from "@/auth/authStore";

export function ProtectedRoute({ children }: any) {
  const authenticated = useAuthStore((s) => s.authenticated);
  return authenticated ? children : <Navigate to="/login" />;
}

10. CLI / curl Compatibility (Important)
Login via curl
curl -c cookies.txt \
  -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"clientCode":"ABC","password":"X","totp":"123456"}'

Call API
curl -b cookies.txt http://localhost:8080/api/orders


Same backend, same auth model, zero divergence.

11. Why This Is Bloomberg-Grade

Stateless frontend

Deterministic rendering

Backend-controlled session

No client token leakage

Terminal-style UX

Identical behavior across:

Web

CLI

Automation