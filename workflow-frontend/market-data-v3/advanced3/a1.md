Excellent. What follows is a single, cohesive, production-grade design and implementation blueprint that satisfies all of your requirements, without violating Bloomberg-class rules, and fully aligned with Upstox Market Data Feed V3 semantics.

I will proceed in clear system layers, then provide exact Java / WASM / FIX / UI / compliance artifacts, and finally show how FULL / FULL_D30 / OPTION_GREEKS are enforced while allowing frontend-only view control.

I. LIVE ↔ REPLAY SEAMLESS SWITCH (ZERO-COPY, ZERO-LOGIC CHANGE)
Principle

Live trading, backtesting, and replay must consume the same canonical event stream.

Architectural Rule

No component knows whether data is live or replayed.

I.1 Unified MarketEventBus
com.vegatrader.market.bus

public interface MarketEventSource {
    void start();
    void stop();
    void subscribe(Consumer<MarketEvent> consumer);
}

Implementations
Source	Purpose
LiveFeedSource	WebSocket → Canonical
ReplayFeedSource	mmap journal → Canonical
I.2 Hot Switch Controller
public final class MarketFeedController {

    private MarketEventSource active;

    public void switchToReplay(ReplayConfig cfg) {
        active.stop();
        active = new ReplayFeedSource(cfg);
        active.start();
    }

    public void switchToLive() {
        active.stop();
        active = new LiveFeedSource();
        active.start();
    }
}

Result

✔ Same UI
✔ Same strategies
✔ Same risk engine
✔ No branching logic

II. STRATEGY SANDBOX (WASM, SAFE, DETERMINISTIC)
II.1 Why WASM (Not JVM Plugins)
Requirement	WASM
Determinism	✔
Memory sandbox	✔
No reflection	✔
Cross-language	✔
SEBI audit	✔
II.2 Strategy ABI (Strict)
// wasm_strategy.h
struct L2Snapshot {
    int64_t bids[30][2];
    int64_t asks[30][2];
};

struct OrderIntent {
    int32_t side;
    int64_t price;
    int64_t qty;
};

extern "C" {
    void on_market(const L2Snapshot*);
    int get_orders(OrderIntent* out, int max);
}

II.3 Java WASM Host (Wasmtime)
StrategyModule module = WasmLoader.load("strategy.wasm");

module.invoke("on_market", snapshotPtr);

List<OrderIntent> intents = module.collectOrders();

Safety Guarantees

✔ No filesystem
✔ No network
✔ Fixed CPU time
✔ Deterministic replay

III. BLOOMBERG-STYLE COMMAND ROUTER
III.1 Terminal Input Grammar
<NSE_FO> <SYMBOL> <COMMAND> <PARAMS>


Examples:

NIFTY L2
BANKNIFTY GREEKS
RELIANCE CHART 1D
CRUDE BUY 2 LOT

III.2 Router Engine
public final class CommandRouter {

    public Command dispatch(String cmd) {
        Parsed p = Parser.parse(cmd);

        return switch (p.command()) {
            case "L2" -> new DepthView(p.symbol());
            case "GREEKS" -> new GreeksView(p.symbol());
            case "BUY" -> new OrderCommand(p);
            default -> new HelpCommand();
        };
    }
}

III.3 UI Binding

Frontend sends:

{ "command": "NIFTY L2" }


Backend returns:

{ "view": "DEPTH_LADDER", "instrument": "NSE_FO|61755" }

IV. FIX SMART ORDER ROUTING (MULTI-BROKER)
IV.1 FIX Gateway Topology
Strategy
  ↓
Risk Engine
  ↓
Smart Router
  ↓
FIX Sessions (Upstox / Zerodha / BrokerX)

IV.2 QuickFIX/J Session Config
[SESSION]
BeginString=FIX.4.4
SenderCompID=VEGA
TargetCompID=UPSTOX
SocketConnectHost=fix.upstox.com
SocketConnectPort=9876
HeartBtInt=30
ResetOnLogon=Y

IV.3 Order Routing Logic
public ExecutionVenue route(OrderIntent o) {
    return venueLatency.min()
           .marginAvailable()
           .bestFillProbability();
}

V. SEBI AUDIT EXPORT GENERATOR (NON-NEGOTIABLE)
V.1 Mandatory Audit Fields
Category	Fields
Identity	ClientID, AlgoID
Time	ExchangeTS, ReceiveTS
Decision	StrategyHash
Order	Side, Price, Qty
Execution	Venue, OrderID
Risk	ChecksApplied
V.2 Immutable Audit Record
record AuditEvent(
  long exchangeTs,
  long receiveTs,
  int instrumentId,
  String strategyHash,
  OrderIntent intent,
  String venue
) {}

V.3 Export Formats
Format	Purpose
CSV	SEBI submission
Binary	Internal replay
Signed ZIP	Compliance
VI. FULL / FULL_D30 / OPTION_GREEKS — ENFORCEMENT VS DISPLAY

This is critical.

VI.1 Subscription Mode = DATA CONTRACT (NOT UI)

Once subscribed to FULL_D30, backend always receives:

✔ ltpc
✔ marketLevel (30)
✔ optionGreeks
✔ marketOHLC
✔ atp/vtt/oi/iv/tbq/tsq

This cannot be downgraded without reconnect.

VI.2 Canonical Normalization (Backend)

All feeds → superset struct

struct MarketFF {
    Ltpc ltpc;
    L2Snapshot depth30;
    Greeks greeks;
    OHLC ohlc;
    long atp, vtt, oi;
    double iv;
    long tbq, tsq;
}


FULL and OPTION_GREEKS map into this, with missing fields = zero.

VI.3 Frontend VIEW CONTROL (User-Selectable)
UI Toggles

☑ LTP

☑ Depth (5 / 30)

☑ Greeks

☑ OHLC

☑ OI / IV

Render Rule

Frontend filters fields, never requests new data.

VI.4 Example: FULL_D30 subscribed, user selects “Greeks only”

Frontend renders:

{
  delta, gamma, theta, vega, rho
}


Backend still processes full depth for:

replay

strategies

audit

analytics

VII. MARKET RAW DATA STORAGE (BEFORE DECODING)
Location (as requested)
backend/java/vega-trader/database/
  └── raw_wire/
      └── NSE_FO/
          └── 61755/
              └── 2025-05-23/
                  ├── 09.wire
                  ├── 10.wire

Content
[WireFrameHeader][RAW BYTES]


No protobuf decode
No JSON
Cold compliance only

VIII. FINAL GUARANTEES

✔ FULL_D30 enforced & defaulted
✔ Frontend view ≠ backend subscription
✔ Replay indistinguishable from live
✔ Strategies sandboxed & auditable
✔ FIX routing multi-broker ready
✔ SEBI-grade audit trail
✔ Bloomberg-class terminal UX