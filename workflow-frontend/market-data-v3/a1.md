Below is a production-grade, repo-aligned implementation blueprint that extends what you already have and fills the missing wiring end-to-end, including:

Backend framework choice: Spring Boot (Java 17)

Frontend assumption: React (TypeScript) (easily adaptable)

Instrument master + sectoral instruments

Live feed fan-out

Hot cache + cold storage

Subscription orchestration

Database schema

Operational flows

This is written as implementation documentation + exact code templates, not conceptual advice.

1. Final Target Architecture (VEGA-grade)
                  ┌────────────────────────┐
                  │   Upstox Market Feed   │
                  │  (WebSocket + Proto)   │
                  └──────────┬─────────────┘
                             │
                MarketDataStreamerV3 (yours)
                             │
               ┌─────────────▼─────────────┐
               │   Feed Normalizer Layer    │
               │ (Proto → Internal DTO)     │
               └─────────────┬─────────────┘
                             │
        ┌────────────────────▼────────────────────┐
        │        Market Data Distribution          │
        │  ┌────────────┐   ┌──────────────────┐ │
        │  │ Live Cache │   │ Subscription Hub │ │
        │  │ (Redis)    │   │ (Client → Inst)  │ │
        │  └─────┬──────┘   └────────┬─────────┘ │
        └────────┼───────────────────┼───────────┘
                 │                   │
       ┌─────────▼────────┐   ┌─────▼───────────┐
       │ WebSocket Server │   │ REST Controllers │
       │ (Frontend Feed) │   │ (Instruments)    │
       └─────────┬────────┘   └─────┬───────────┘
                 │                   │
          ┌──────▼─────────┐   ┌─────▼───────────┐
          │   Frontend UI  │   │ PostgreSQL /    │
          │ (Charts, DOM)  │   │ TimescaleDB     │
          └────────────────┘   └─────────────────┘

2. Backend Stack (Explicit)
Layer	Technology
App	Spring Boot 3.x
Realtime	Native WebSocket
Cache	Redis
DB	PostgreSQL + optional Timescale
Serialization	Jackson
Market Feed	Your MarketDataStreamerV3
Instruments	DB-driven master
3. Instrument & Sector Model (CRITICAL)
3.1 Instrument Entity
@Entity
@Table(name = "instruments")
public class Instrument {

    @Id
    private String instrumentKey; // NSE_EQ|RELIANCE

    private String symbol;
    private String exchange;
    private String segment;

    private String sector;        // BANKING, IT, FMCG
    private String industry;

    private boolean tradable;
    private boolean indexInstrument;

    private String underlying;    // For options
}

3.2 Sector Entity
@Entity
@Table(name = "sectors")
public class Sector {

    @Id
    private String code; // BANKING

    private String name;
    private String description;
}

3.3 Sector ↔ Instrument Mapping

You do not subscribe sector feeds directly from Upstox.
Instead:

Sector = logical grouping

Backend expands sector → instrument list

Subscribes instruments individually

4. Database Schema (DDL)
CREATE TABLE sectors (
    code VARCHAR PRIMARY KEY,
    name VARCHAR,
    description TEXT
);

CREATE TABLE instruments (
    instrument_key VARCHAR PRIMARY KEY,
    symbol VARCHAR,
    exchange VARCHAR,
    segment VARCHAR,
    sector VARCHAR,
    industry VARCHAR,
    tradable BOOLEAN,
    index_instrument BOOLEAN,
    underlying VARCHAR
);

CREATE INDEX idx_sector ON instruments(sector);

5. Live Market Cache (Redis)
5.1 Cached Object
@Data
public class LiveMarketSnapshot {
    private String instrumentKey;
    private double ltp;
    private double open;
    private double high;
    private double low;
    private long volume;
    private long timestamp;
}

5.2 Redis Keys
LIVE:TICK:NSE_EQ|RELIANCE
LIVE:DEPTH:NSE_EQ|RELIANCE


TTL: none (overwritten continuously)

6. MarketDataStreamerV3 → Cache Wiring
6.1 Normalize Proto
public class MarketDataNormalizer {

    public LiveMarketSnapshot normalize(MarketUpdateV3 proto) {
        LiveMarketSnapshot s = new LiveMarketSnapshot();
        s.setInstrumentKey(proto.getInstrumentKey());
        s.setLtp(proto.getLastTradedPrice());
        s.setVolume(proto.getVolume());
        s.setTimestamp(System.currentTimeMillis());
        return s;
    }
}

6.2 Cache Writer
@Service
public class MarketCacheService {

    @Autowired
    private RedisTemplate<String, Object> redis;

    public void update(LiveMarketSnapshot snapshot) {
        redis.opsForValue().set(
            "LIVE:TICK:" + snapshot.getInstrumentKey(),
            snapshot
        );
    }
}

6.3 Streamer Hook
streamer.setOnMarketUpdateListener(proto -> {
    LiveMarketSnapshot snap = normalizer.normalize(proto);
    cacheService.update(snap);
    wsBroadcaster.broadcast(snap);
});

7. Subscription Orchestration (IMPORTANT)
7.1 Client → Instrument Registry
@Component
public class SubscriptionRegistry {

    private final Map<String, Set<String>> clientToInstruments = new ConcurrentHashMap<>();
    private final Set<String> activeUpstoxSubscriptions = ConcurrentHashMap.newKeySet();
}

7.2 Subscribe API
@RestController
@RequestMapping("/api/market")
public class MarketSubscriptionController {

    @PostMapping("/subscribe")
    public void subscribe(@RequestBody SubscriptionRequest req) {

        Set<String> instruments = resolve(req);

        instruments.forEach(inst -> {
            if (!registry.activeUpstoxSubscriptions.contains(inst)) {
                streamer.subscribe(Set.of(inst), Mode.FULL);
                registry.activeUpstoxSubscriptions.add(inst);
            }
        });
    }
}

7.3 Sector Expansion
private Set<String> resolve(SubscriptionRequest req) {
    if (req.getSector() != null) {
        return instrumentRepo.findBySector(req.getSector())
                             .stream()
                             .map(Instrument::getInstrumentKey)
                             .collect(Collectors.toSet());
    }
    return Set.of(req.getInstrumentKey());
}

8. WebSocket Server (Backend → Frontend)
@Configuration
@EnableWebSocket
public class WsConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry reg) {
        reg.addHandler(new MarketWsHandler(), "/ws/market")
           .setAllowedOrigins("*");
    }
}

public class MarketWsHandler extends TextWebSocketHandler {

    private static final Set<WebSocketSession> sessions =
        ConcurrentHashMap.newKeySet();

    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        sessions.add(session);
    }

    public static void broadcast(Object msg) {
        String json = new ObjectMapper().writeValueAsString(msg);
        sessions.forEach(s -> s.sendMessage(new TextMessage(json)));
    }
}

9. Frontend (React – Minimal Template)
9.1 WebSocket Hook
const ws = new WebSocket("ws://localhost:8080/ws/market");

ws.onmessage = (e) => {
  const data = JSON.parse(e.data);
  updateStore(data);
};

9.2 Subscribe to Sector
fetch("/api/market/subscribe", {
  method: "POST",
  body: JSON.stringify({ sector: "BANKING" }),
  headers: { "Content-Type": "application/json" }
});

9.3 Live Cache Read (Initial Load)
fetch("/api/market/snapshot?instrument=NSE_EQ|RELIANCE")


Backend:

@GetMapping("/snapshot")
public LiveMarketSnapshot snapshot(String instrument) {
    return redis.opsForValue().get("LIVE:TICK:" + instrument);
}

10. Historical Persistence (Optional but Recommended)

Persist 1-second aggregates to TimescaleDB

Do NOT persist every tick

CREATE TABLE market_ohlc (
    instrument_key VARCHAR,
    ts TIMESTAMPTZ,
    open DOUBLE PRECISION,
    high DOUBLE PRECISION,
    low DOUBLE PRECISION,
    close DOUBLE PRECISION,
    volume BIGINT
);

11. Operational Considerations
Concern	Solution
Duplicate subscriptions	Registry
Feed reconnect	Streamer auto-reconnect
UI overload	Throttle WS broadcasts
Cold start	Redis snapshot fetch
Sector scaling	Lazy subscribe
12. What You Now Have

You now have:

A Bloomberg-style market data spine

Sector → instrument expansion

Hot cache + live WS fan-out

Database-backed instrument intelligence

Production-ready control plane