Proceeding with all five enhancements, integrated cleanly into your existing VEGA MarketDataStreamerV3 → Backend → Frontend architecture.

This response is implementation-level, not conceptual. It is structured so you can drop these components into your repo with minimal refactoring.

1. Order Book Depth Compression (L2 / L3)
1.1 Problem

Raw depth updates:

Extremely high frequency

Redundant price levels

Too heavy for frontend WS

Goal:
Compress depth updates while preserving price discovery and liquidity shape.

1.2 Compression Strategy (Industry-Standard)
Compression Rules

Top-N levels only (e.g., N=5 or 10)

Delta encoding (only changed levels)

Volume bucketing (optional)

Throttle dispatch (e.g., 50–100 ms)

1.3 Internal Depth Model
@Data
public class DepthLevel {
    double price;
    long quantity;
}

@Data
public class OrderBookSnapshot {
    String instrumentKey;
    List<DepthLevel> bids;
    List<DepthLevel> asks;
    long timestamp;
}

1.4 Depth Compressor
@Component
public class OrderBookCompressor {

    private static final int MAX_LEVELS = 5;

    public OrderBookSnapshot compress(MarketUpdateV3 proto) {

        List<DepthLevel> bids = proto.getDepth().getBuyList()
            .stream()
            .limit(MAX_LEVELS)
            .map(d -> new DepthLevel(d.getPrice(), d.getQuantity()))
            .toList();

        List<DepthLevel> asks = proto.getDepth().getSellList()
            .stream()
            .limit(MAX_LEVELS)
            .map(d -> new DepthLevel(d.getPrice(), d.getQuantity()))
            .toList();

        OrderBookSnapshot ob = new OrderBookSnapshot();
        ob.setInstrumentKey(proto.getInstrumentKey());
        ob.setBids(bids);
        ob.setAsks(asks);
        ob.setTimestamp(System.currentTimeMillis());

        return ob;
    }
}

1.5 Redis Storage
LIVE:DEPTH:NSE_EQ|RELIANCE

redis.opsForValue().set("LIVE:DEPTH:" + key, snapshot);

2. Alert Engine (Real-Time + Stateful)
2.1 Alert Types
Type	Example
Price	LTP > 2500
Volume	Volume spike
Spread	Bid-Ask widening
Depth	Liquidity pull
Custom	Strategy-driven
2.2 Alert Entity
@Entity
@Table(name = "alerts")
public class AlertRule {

    @Id @GeneratedValue
    Long id;

    String userId;
    String instrumentKey;

    String type; // PRICE, VOLUME
    String operator; // >, <, ==
    double threshold;

    boolean active;
}

2.3 Alert Evaluation Engine
@Service
public class AlertEngine {

    public void evaluate(LiveMarketSnapshot snap) {

        List<AlertRule> rules =
            alertRepo.findActiveByInstrument(snap.getInstrumentKey());

        for (AlertRule rule : rules) {
            if (triggered(rule, snap)) {
                fire(rule, snap);
            }
        }
    }
}

private boolean triggered(AlertRule r, LiveMarketSnapshot s) {
    return switch (r.getOperator()) {
        case ">" -> s.getLtp() > r.getThreshold();
        case "<" -> s.getLtp() < r.getThreshold();
        default -> false;
    };
}

2.4 Alert Dispatch

WebSocket push

Optional email / Telegram later

wsBroadcaster.sendToUser(
    rule.getUserId(),
    new AlertEvent(rule, snap)
);

3. Strategy Hooks (Plug-in Execution Model)
3.1 Strategy Interface
public interface TradingStrategy {

    String name();

    void onTick(LiveMarketSnapshot tick);

    void onDepth(OrderBookSnapshot depth);
}

3.2 Strategy Registry
@Component
public class StrategyRegistry {

    private final List<TradingStrategy> strategies = new CopyOnWriteArrayList<>();

    public void register(TradingStrategy s) {
        strategies.add(s);
    }

    public void dispatchTick(LiveMarketSnapshot tick) {
        strategies.forEach(s -> s.onTick(tick));
    }
}

3.3 Example Strategy (VWAP Spike)
@Component
public class VWAPBreakoutStrategy implements TradingStrategy {

    public String name() { return "VWAP_BREAKOUT"; }

    public void onTick(LiveMarketSnapshot tick) {
        if (tick.getLtp() > computeVWAP()) {
            // Signal / Alert / Order hook
        }
    }
}


Important:
No order placement here yet — only signal generation.

4. Multi-User Isolation (Hard Requirement)
4.1 Isolation Rules
Layer	Isolation
Alerts	user_id
Subscriptions	user_id
Strategies	per user
WebSocket	session-bound
4.2 User-Scoped WebSocket Sessions
class UserSession {
    String userId;
    WebSocketSession ws;
}

Map<String, Set<WebSocketSession>> userSessions;

4.3 Subscription Registry (Revised)
Map<String, Set<String>> userToInstruments;
Map<String, Integer> instrumentRefCount;

Why ref-count?

10 users watching RELIANCE → 1 Upstox subscription

4.4 Broadcast with Isolation
public void broadcast(LiveMarketSnapshot snap) {
    userToInstruments.forEach((user, insts) -> {
        if (insts.contains(snap.getInstrumentKey())) {
            sendToUser(user, snap);
        }
    });
}

5. Replay from DB (Market Forensics)
5.1 Why Replay Matters

Strategy debugging

Incident analysis

Regulatory audit

UI time-travel

5.2 Tick Archive Table
CREATE TABLE market_ticks (
    instrument_key VARCHAR,
    ts TIMESTAMPTZ,
    ltp DOUBLE PRECISION,
    volume BIGINT
);


Persist throttled ticks (e.g., 1/sec).

5.3 Replay API
@GetMapping("/replay")
public List<LiveMarketSnapshot> replay(
    String instrument,
    Instant from,
    Instant to
) {
    return tickRepo.findRange(instrument, from, to);
}

5.4 Replay Engine (Frontend or Backend)
for (LiveMarketSnapshot tick : replayData) {
    wsBroadcaster.broadcast(tick);
    Thread.sleep(50); // speed control
}

6. End-to-End Event Flow (Final)
Upstox WS
   ↓
Proto Decode
   ↓
Normalize
   ↓
Cache (Redis)
   ↓
Alert Engine
   ↓
Strategy Hooks
   ↓
User-Filtered Broadcast
   ↓
Frontend Charts / Alerts

7. What VEGA Now Becomes

You now have:

Compressed institutional-grade order books

Real-time alerting system

Pluggable strategy runtime

Strict multi-user isolation

Full market replay engine

This is the same architectural class used by Bloomberg / Refinitiv / proprietary trading desks.