1. First Principle: What “RAW” Means in Bloomberg Terms

RAW ≠ protobuf bytes
RAW ≠ WebSocket frames
RAW ≠ decoded JSON

RAW market data is the first canonical, transport-agnostic representation of market state after wire ingestion.

Bloomberg never stores:

WebSocket frames

HTTP payloads

Protobuf blobs

JSON

Those are transport artifacts, not data.

2. Actual Bloomberg-Style Data Pipeline (Layered)

This is the exact conceptual layering Bloomberg / Refinitiv / Exchange colos use.

L0: Transport Layer        (WebSocket / TCP / UDP)
L1: Wire Capture Layer    (binary frame capture)
L2: Canonical Event Layer (normalized binary events)
L3: Journal Layer         (append-only persistence)
L4: Cache Layer           (hot memory views)
L5: Analytics Layer       (derived state)
L6: Presentation Layer    (terminal UI)


Each layer is strictly separated.

3. L0–L1: Wire Capture (Before Protobuf)
What your VEGA system currently does

Your MarketDataStreamerV3:

Receives WebSocket binary messages

Decodes protobuf immediately

What Bloomberg does differently

Bloomberg splits ingestion into two paths:

WebSocket Frame
   ├── Path A: Immediate decode (for live UI)
   └── Path B: RAW capture (for storage)


RAW capture happens before protobuf decoding.

3.1 RAW Wire Frame Record

Every received message is captured with a minimal envelope.

Binary Wire Frame Header
struct WireFrameHeader {
    uint64_t recv_ts_ns;       // local receive time
    uint32_t conn_id;          // websocket/session id
    uint32_t payload_size;     // size of raw payload
    uint16_t protocol;         // 1=WS, 2=TCP
    uint16_t compression;      // 0=none, 1=gzip
};

Followed by:
[WireFrameHeader][RAW PAYLOAD BYTES]


No parsing.
No decoding.
No protobuf dependency.

This is wire-faithful capture.

4. Why Bloomberg Still Doesn’t Stop Here

Wire frames are:

Version-fragile

Protocol-dependent

Hard to replay across versions

So Bloomberg does NOT use wire frames for analytics.

They are cold archival only.

5. L2: Canonical Binary Market Events (Critical Layer)

This is where Bloomberg’s real power begins.

Rule:

Convert raw feed → canonical binary events immediately, then discard protocol specifics.

This is NOT protobuf decoding.
This is semantic normalization.

5.1 Canonical Event Header (Universal)

Every market event begins with this.

struct MarketEventHeader {
    uint64_t sequence;
    uint64_t exchange_ts_ns;
    uint64_t receive_ts_ns;
    uint32_t instrument_id;
    uint16_t event_type;   // SNAPSHOT_L2, TRADE, OHLC, GREEKS
    uint16_t payload_len;
};


This header is:

Stable forever

Protocol-independent

Replay-safe

6. Canonical RAW L2 Book Representation (Bloomberg Style)

Bloomberg does not store bidAsk arrays.

They store deterministic book state.

Fixed-Depth Snapshot (e.g., 30)
struct BookLevel {
    int64_t price;     // scaled (price * 10^4)
    int64_t qty;
};

struct L2Snapshot {
    uint8_t depth;
    BookLevel bids[30];
    BookLevel asks[30];
};

Final Record on Disk
[MarketEventHeader]
[L2Snapshot]


This is:

Binary

Fixed layout

Zero allocations

Cache-friendly

7. Storage Strategy (Bloomberg Reality)

Bloomberg does not use databases for tick data.

Storage tiers:
Tier	Purpose	Technology
Hot	Live UI	Shared memory
Warm	Replay / analytics	Memory-mapped files
Cold	Compliance	Compressed archives
8. File Structure (Production-Grade)
Directory Layout
/marketdata/
  └── NSE_FO/
      └── 61755/
          ├── 2025-05-23/
          │   ├── 09.bin
          │   ├── 10.bin
          │   └── 11.bin

File Header
struct JournalFileHeader {
    uint32_t magic;      // 'MDJ1'
    uint16_t version;
    uint16_t depth;
    uint32_t instrument_id;
};

Body
[Event][Event][Event]...


Append-only. Never updated.

9. Why No Database Is Used

Databases introduce:

Locks

Serialization overhead

Index maintenance

GC pressure

Bloomberg uses:

Append-only binary logs

OS page cache

Memory mapping

10. L4: Cache Layer (Hot Book)

For UI speed, Bloomberg maintains live book views in memory.

Binary Event
   ↓
Book Builder
   ↓
Shared Memory Snapshot


Characteristics:

One writer

Many readers

Lock-free

Versioned pointers

11. Retrieval (Terminal / Analytics)
Terminal UI

Reads shared memory

No disk access

Analytics / Replay

mmap() binary files

Pointer arithmetic

No deserialization

12. How Analytics Work Without Decoding

Analytics never touch protobuf or JSON.

They operate on:

Fixed-width binary structs

Deterministic snapshots

Time-indexed offsets

Example:

PnL Engine → L2Snapshot → Slippage model

13. Your VEGA System: Correct Mapping
VEGA Component	Bloomberg Equivalent
WebSocket client	Feed handler
Protobuf	Wire adapter
MarketDataStreamerV3	Ingestion layer
(Missing) Binary journal	Tick store
(Missing) Replay engine	Analytics feed
14. What You Need to Add (Minimal)
Mandatory

Wire frame capture

Canonical binary event structs

Append-only binary journal

Memory-mapped replay

Optional (Later)

Delta compression

Columnar analytics store

GPU book analytics

15. Absolute Rules (Do Not Break)

❌ Do not store protobuf blobs
❌ Do not store JSON
❌ Do not store floats
❌ Do not rebuild book from trades
❌ Do not query DB for ticks

If any of these happen, the system is not Bloomberg-class.