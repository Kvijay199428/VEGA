1. What “RAW Market Data” Actually Means (Non-Negotiable Definition)

RAW data = the exact market state as seen by the feed handler, stored in a deterministic binary form, without presentation logic.

Important clarifications:

❌ Not Raw	✅ Raw
JSON snapshots	Binary frames
Floating prices	Scaled integers
Aggregated UI models	Canonical book state
Per-field DB rows	Append-only binary records

Bloomberg never stores JSON, and never stores protobuf blobs.

2. Bloomberg-Style Market Data Pipeline (Exact)
NETWORK BYTES
   ↓
WIRE FRAME PARSER
   ↓
CANONICAL MARKET EVENT
   ↓
LOCK-FREE MEMORY BUS
   ↓
APPEND-ONLY BINARY JOURNAL
   ↓
TIME-INDEXED REPLAY ENGINE


Everything else (charts, option chain, DOM, analytics) is derived.

3. Raw Feed Ingestion (Wire Level)

At the lowest level, your system receives:

WebSocket TCP frames

Binary payload

Protobuf-encoded

Bloomberg Rule #1

Do NOT store WebSocket frames. Do NOT store protobuf.

Why:

Transport noise

Version coupling

Undecodable in future

You must convert once into a canonical binary event.

4. Canonical Market Event (The Atomic Unit)

Bloomberg stores events, not objects.

Every market change becomes one immutable binary record.

4.1 Universal Event Header (Used Everywhere)
struct EventHeader {
    uint64_t sequence;          // monotonic
    uint64_t exchange_ts_ns;    // exchange time
    uint64_t receive_ts_ns;     // local capture time
    uint32_t instrument_id;
    uint16_t event_type;        // L1, L2_SNAPSHOT, TRADE, etc.
    uint16_t payload_size;      // bytes following
};


This header exists in every record.

5. RAW L2 Storage Model (Bloomberg-Equivalent)

Bloomberg does NOT store “bidAskQuote[]”.

They store a full depth state at a point in time.

5.1 Canonical L2 Snapshot Payload

Depth is fixed per instrument (e.g., 30).

struct L2Level {
    int64_t price;       // scaled (no floats)
    int64_t quantity;
};

struct L2SnapshotPayload {
    uint8_t depth;
    L2Level bids[30];    // descending
    L2Level asks[30];    // ascending
};

5.2 Full On-Disk Record Layout
[EventHeader]
[L2SnapshotPayload]


No padding. No compression. No metadata.

This is RAW market state.

6. Why Bloomberg Stores SNAPSHOTS, Not Deltas (Critical Insight)

Most people assume Bloomberg stores deltas.
It does not.

Bloomberg stores:

Frequent snapshots

Deterministic state

Rebuildable deltas later

Why?

Reason	Explanation
Crash safety	No dependency on history
Random access	Jump to any timestamp
Determinism	Exact replay
Simplicity	No state corruption

Deltas are derived, not stored.

7. Binary Journal File Format (On Disk)

Each instrument has time-segmented files.

Example
NSE_FO_61755/
  ├── 2025-05-23_09.bin
  ├── 2025-05-23_10.bin
  ├── 2025-05-23_11.bin

7.1 File Header
struct FileHeader {
    uint32_t magic;        // 'MDJ1'
    uint16_t version;
    uint16_t depth;
    uint32_t instrument_id;
};

7.2 File Body
[Event][Event][Event]...


Append-only. Never modified.

8. Memory Mapping (Bloomberg Secret Sauce)

Bloomberg does not read files.
It memory-maps them.

mmap() → pointer arithmetic → zero-copy replay


This enables:

Instant seek

Parallel readers

Zero GC

OS-level caching

9. Retrieval (Replay Engine)

Retrieval is not deserialization.

It is:

EventHeader* hdr = (EventHeader*)ptr;
L2SnapshotPayload* book = (void*)(ptr + sizeof(EventHeader));


Then:

Publish to subscribers

Or rebuild order book

Or render DOM

10. How Bloomberg Builds UI from Raw Data

Bloomberg Terminal never queries a DB.

It:

RAW SNAPSHOT
   ↓
BOOK VIEW
   ↓
DOM VIEW
   ↓
OPTION CHAIN
   ↓
CHARTS


Everything is recomputed live from raw data.

11. What You MUST NOT Do (Hard Rules)

❌ Store decoded JSON
❌ Store protobuf blobs
❌ Store floats
❌ Store per-price DB rows
❌ Reconstruct book from trades

Any of these instantly disqualifies the system from being “Bloomberg-class”.

12. Where Your VEGA System Fits Perfectly

Your existing architecture is already aligned:

VEGA Component	Bloomberg Equivalent
MarketDataStreamerV3	Feed Handler
Protobuf decoder	Wire adapter
Normalizer	Canonicalizer
Ring buffer	Market bus
Binary journal	Tick database

You are missing only the binary journal + replay engine.

13. Minimal Implementation Checklist

To reach Bloomberg-grade raw storage:

Define canonical event structs (C-layout)

Convert feed → canonical snapshot

Append binary records

Memory-map for replay

Build derived views on top