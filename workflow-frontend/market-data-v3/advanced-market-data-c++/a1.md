FINAL SYSTEM ARCHITECTURE
┌──────────────┐
│ Upstox Feed  │
└──────┬───────┘
       ↓ (protobuf)
┌────────────────────────┐
│ C++ Feed Normalizer    │  ← ONLY place protobuf exists
│ (wire → canonical)     │
└──────┬─────────────────┘
       ↓ (C-layout)
┌────────────────────────┐
│ C++ Binary Journal     │  ← RAW truth
│ mmap append-only       │
└──────┬─────────────────┘
       ↓ mmap
┌────────────────────────┐
│ C++ Replay Engine      │
│ (seek, scan, publish) │
└──────┬─────────────────┘
       ↓ shared memory
┌────────────────────────┐
│ Java Market Bus        │
│ (Agrona / JNI)        │
└──────┬─────────────────┘
       ↓
┌────────────────────────┐
│ Java UI / Strategy     │
│ / Routing / Risk       │
└────────────────────────┘

IMPLEMENTATION PLAN (Step-By-Step)
PHASE 1 — Canonical Binary Spec (C ABI)
1.1 Event Header (Single Source of Truth)
#pragma pack(push, 1)

typedef struct {
    uint64_t sequence;
    uint64_t exchange_ts_ns;
    uint64_t receive_ts_ns;
    uint32_t instrument_id;
    uint16_t event_type;
    uint16_t payload_size;
} EventHeader;

#pragma pack(pop)


Rules

Packed

No padding

Little-endian

Frozen forever

Java must not redefine this — it maps it.

1.2 L2 Snapshot Payload
typedef struct {
    int64_t price;
    int64_t quantity;
} L2Level;

typedef struct {
    uint8_t depth;
    L2Level bids[30];
    L2Level asks[30];
} L2SnapshotPayload;

PHASE 2 — C++ RAW Journal (Append-Only)
2.1 File Layout
[FileHeader]
[EventHeader][Payload]
[EventHeader][Payload]
...

2.2 Append Code (C++)
void Journal::append(const EventHeader& hdr, const void* payload) {
    memcpy(writePtr, &hdr, sizeof(hdr));
    writePtr += sizeof(hdr);

    memcpy(writePtr, payload, hdr.payload_size);
    writePtr += hdr.payload_size;
}


No serialization.
No objects.
No heap.

PHASE 3 — Memory-Mapped Replay Engine (C++)
EventHeader* hdr = (EventHeader*)ptr;
L2SnapshotPayload* book =
    (L2SnapshotPayload*)(ptr + sizeof(EventHeader));


Seeking:

Binary search on timestamps

Pointer arithmetic

Zero allocations

PHASE 4 — Java Alignment Rules (CRITICAL)
4.1 Java Must NEVER Reconstruct Data

Java sees views, not objects.

public interface L2SnapshotView {
    long bidPrice(int level);
    long bidQty(int level);
}


Backed by:

DirectByteBuffer

Or JNI pointer

4.2 Java ↔ C++ Boundary Options
Method	Use Case
JNI	Lowest latency
JEP-454 FFM	Safer, modern
Agrona Shared Memory	UI feeds

Recommended

JNI for replay + feed

Agrona for UI

PHASE 5 — Shared Memory UI Feed
C++ Publisher
memcpy(sharedRing.next(), snapshot, sizeof(*snapshot));

Java Subscriber
DirectBuffer buf = ringBuffer.read();
long bestBid = buf.getLong(offset);


No JSON.
No serialization.
No Kafka.

PHASE 6 — Delta Compression (Derived Layer)
Bloomberg Rule:

Store snapshots. Derive deltas.

Compression Algorithm (Optional)

XOR price deltas

RLE for unchanged levels

Dictionary per instrument

Stored as:

[Snapshot]
[Delta]
[Delta]
[Snapshot]


Never replace snapshots.

PHASE 7 — Strategy / Analytics Layer
Strategy Execution

Java or WASM

Reads shared memory

Cannot write RAW data

Backtesting

Uses same replay engine

Bit-identical

Latency Considerations (Java vs C++)
Aspect	C++	Java
mmap	Native	Limited
Pointer arithmetic	Yes	Unsafe
GC impact	None	Yes
ABI stability	Strong	Weak
Replay speed	Best	Acceptable

Conclusion
RAW path must be C++.
Java remains first-class consumer.

What You Should NOT Attempt

❌ RAW journals in Java
❌ Protobuf storage
❌ JSON anywhere near feed
❌ DB for market data
❌ Object graphs for book state

Final Recommendation (Authoritative)

Do this:

C++ owns truth

Java consumes truth

Java never mutates truth

Java never serializes truth